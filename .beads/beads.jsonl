{"id":"recurse-038","content_hash":"396696b2f5961c9096625ac932eee360a054fcf621d8836cdca122bfacc72cec","title":"RLM Enhancement: Critical Infrastructure","description":"Critical infrastructure improvements from rlm-claude-code analysis. These are highest-impact, foundational changes that enable other enhancements.\n\nResearch basis:\n- RLM Paper (arxiv 2512.24601): Notes serial execution as key limitation\n- Anthropic prompt caching: 90% cost reduction, 85% latency reduction\n- A-MEM/Zep research: Semantic retrieval significantly improves memory quality\n\nIncludes:\n- Async recursive calls (3-5x latency reduction)\n- Embedding integration (semantic memory search)\n- Prompt caching optimization (90% cost reduction)\n- Circuit breaker pattern (resilience)","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-13T19:53:06.156549-07:00","updated_at":"2026-01-14T08:51:39.804513-07:00","closed_at":"2026-01-14T08:51:39.804513-07:00","source_repo":".","labels":["high-impact","infrastructure","rlm"]}
{"id":"recurse-03d","content_hash":"5b456509ec8e2cacf948c03cfc5a491751c019e12cd384984c62117f0deeb141","title":"Implement task tier working memory","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T12:44:43.243547-07:00","updated_at":"2026-01-10T14:58:16.067189-07:00","closed_at":"2026-01-10T14:58:16.067189-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-03d","depends_on_id":"recurse-5je","type":"blocks","created_at":"2026-01-10T12:45:36.127199-07:00","created_by":"daemon"}]}
{"id":"recurse-0ef","content_hash":"2a44c54b24d119cca3124c6c8fafe7faa74fb83fdf5bb28d139d648ca102d8be","title":"[SPEC] LATS Tool Orchestration Design","description":"Design specification for LATS-inspired tool orchestration.\n\n## Research Basis\nLATS (ICML 2024) uses MCTS for tool orchestration, doubling ReAct performance on HotPotQA.\n\n## Requirements\n- Define ToolPlan structure with steps and dependencies\n- Specify UCB1 exploration/exploitation balance\n- Design MCTS phases: Select, Expand, Simulate, Backpropagate\n- Define tool capability matrix for planning\n- Specify fallback strategies for failed steps\n\n## Deliverables\n- Spec document: docs/spec/lats-orchestration.md\n- Interface: internal/rlm/lats/orchestrator.go\n- Tool capability matrix: internal/rlm/lats/capabilities.go\n\n## Acceptance Criteria\n- [ ] Spec covers MCTS phases for tool planning\n- [ ] Spec covers UCB1 score computation\n- [ ] Spec covers tool capability matrix\n- [ ] Spec covers fallback handling\n- [ ] Spec defines integration with RLM Controller","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-13T19:56:09.853599-07:00","updated_at":"2026-01-13T20:20:29.047233-07:00","closed_at":"2026-01-13T20:20:29.047233-07:00","source_repo":".","labels":["lats","spec","tools"],"dependencies":[{"issue_id":"recurse-0ef","depends_on_id":"recurse-5gr","type":"parent-child","created_at":"2026-01-13T20:02:07.853105-07:00","created_by":"daemon"}]}
{"id":"recurse-0gy","content_hash":"59ef308f849a5305e82c3483572464c94843f03bb84625e507fef889a38152d7","title":"Implement REPLPluginManager","description":"Implement REPL plugin system for extensibility.\n\n## Implementation\n- Create internal/rlm/repl/plugin.go\n- Define REPLPlugin and REPLFunction interfaces\n- Implement PluginManager for registration\n- Add plugin discovery from ~/.recurse/plugins/\n- Create example CodeAnalysisPlugin\n\n## Key Types\n```go\ntype REPLPlugin interface {\n    Name() string\n    Functions() map[string]REPLFunction\n    OnLoad(env *REPLEnvironment) error\n}\n\ntype REPLFunction struct {\n    Name        string\n    Description string\n    Handler     func(args ...any) (any, error)\n}\n\ntype PluginManager struct {\n    plugins map[string]REPLPlugin\n}\n```","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-13T19:59:35.118503-07:00","updated_at":"2026-01-13T19:59:35.118503-07:00","source_repo":".","labels":["implementation","plugins","repl"],"dependencies":[{"issue_id":"recurse-0gy","depends_on_id":"recurse-t8p","type":"blocks","created_at":"2026-01-13T20:01:45.306809-07:00","created_by":"daemon"}]}
{"id":"recurse-0i9","content_hash":"c25833d791fb1377c4bb4179429f00b534a984e17c05a6f68d37202d292d474a","title":"Implement memory tools (store, query, relate)","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T12:44:43.560128-07:00","updated_at":"2026-01-11T06:16:01.733047-07:00","closed_at":"2026-01-11T06:16:01.733047-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-0i9","depends_on_id":"recurse-03d","type":"blocks","created_at":"2026-01-10T12:45:36.473622-07:00","created_by":"daemon"}]}
{"id":"recurse-0ol","content_hash":"7e97b14b22f6f309dc5635aa666c2764537658fe7209708603ef74ba0f35568b","title":"Fork Crush and establish build pipeline","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T12:14:00.374397-07:00","updated_at":"2026-01-10T12:22:53.310504-07:00","closed_at":"2026-01-10T12:22:53.310504-07:00","source_repo":"."}
{"id":"recurse-0pm","content_hash":"7a9bf2d9b1d0e8c7fd780e2b8ec6f38724dc68588a54b918485c09adf22b54ce","title":"Implement Tool Capability Matrix","description":"Implement tool capability matrix for LATS planning.\n\n## Implementation\n- Create internal/rlm/lats/capabilities.go\n- Define ToolCapability enum (FILE_READ, FILE_WRITE, SEARCH, etc.)\n- Create capability matrix for all agent tools\n- Add capability matching for query requirements\n- Add cost/latency estimates per tool\n\n## Key Types\n```go\ntype ToolCapability string\nconst (\n    CapFileRead      ToolCapability = \"FILE_READ\"\n    CapFileWrite     ToolCapability = \"FILE_WRITE\"\n    CapSearch        ToolCapability = \"SEARCH\"\n    CapCodeExecution ToolCapability = \"CODE_EXECUTION\"\n    CapMemoryQuery   ToolCapability = \"MEMORY_QUERY\"\n    // ...\n)\n\ntype ToolProfile struct {\n    Name         string\n    Capabilities []ToolCapability\n    CostEstimate float64\n    LatencyMS    int\n}\n\nvar ToolMatrix = map[string]ToolProfile{...}\n```","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-13T19:56:11.159385-07:00","updated_at":"2026-01-14T09:43:07.122517-07:00","closed_at":"2026-01-14T09:43:07.122517-07:00","source_repo":".","labels":["implementation","lats","tools"],"dependencies":[{"issue_id":"recurse-0pm","depends_on_id":"recurse-0ef","type":"blocks","created_at":"2026-01-13T20:00:47.88021-07:00","created_by":"daemon"},{"issue_id":"recurse-0pm","depends_on_id":"recurse-98r","type":"blocks","created_at":"2026-01-13T20:00:48.50371-07:00","created_by":"daemon"}]}
{"id":"recurse-0uv","content_hash":"cb2dccf2db21113327038881f69f50fadf0e9710c68790a17c245b8ed5858525","title":"Evolution audit log not persisting to database","description":"The evolution_log table in the hypergraph database is always empty because:\n\n1. **DefaultAuditConfig has Path: \"\"** - File-based logging disabled by default\n2. **In-memory logging only** - Audit entries only kept in memory buffer\n3. **evolution_log table never written to** - The DB table and in-memory audit logger are separate systems\n\n**Evidence:**\n```sql\nSELECT COUNT(*) FROM evolution_log;\n-- Returns: 0\n```\n\n**Impact:**\n- No audit trail for memory evolution operations\n- Cannot debug or analyze consolidation/promotion behavior\n- Lost visibility into system behavior across sessions\n\n**Fix options:**\n1. Write audit entries to the evolution_log table instead of/in addition to file\n2. Configure a default audit log path in ServiceConfig\n3. Add a method to sync in-memory audit buffer to database","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-13T17:36:04.179498-07:00","updated_at":"2026-01-13T18:32:06.672626-07:00","closed_at":"2026-01-13T18:32:06.672626-07:00","source_repo":".","labels":["memory","observability"]}
{"id":"recurse-0yb","content_hash":"7ecb2004ba92c55fca4ee952559a5f75835bf12311a2b04fa8f3179781732161","title":"Implement hypergraph SQLite schema","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T12:44:41.874487-07:00","updated_at":"2026-01-10T12:49:29.538283-07:00","closed_at":"2026-01-10T12:49:29.538283-07:00","source_repo":"."}
{"id":"recurse-10h","content_hash":"fd6944718ab4456b4c7113996c5518ed0c6e58e13b513436c7196469446e748b","title":"RLM Enhancement: Reliability \u0026 Resilience","description":"Reliability and resilience improvements for production robustness.\n\nResearch basis:\n- RLM Paper: Acknowledges lack of strong guarantees on cost/runtime\n- Standard distributed systems patterns for fault tolerance\n\nIncludes:\n- Execution guarantees (hard boundaries)\n- Confidence-weighted synthesis\n- Graceful degradation plans","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-13T19:53:07.964489-07:00","updated_at":"2026-01-14T11:30:39.456932-07:00","closed_at":"2026-01-14T11:30:39.456932-07:00","source_repo":".","labels":["reliability","resilience","rlm"]}
{"id":"recurse-1x9","content_hash":"971236314a5645f7c515ac95d62b1797ab0eeec342b0d788f9b2b7c76979a694","title":"RLM service needs main LLM client for response generation","description":"The RLM architecture has a meta-controller (Haiku) for orchestration decisions, but lacks a main LLM client for generating actual responses.\n\n**Current architecture gap:**\n- Meta-controller: Claude Haiku - decides strategy (DIRECT, DECOMPOSE, etc.)\n- Main LLM: **MISSING** - needed when meta-controller decides DIRECT\n\n**SPEC expectation (from docs/SPEC.md):**\nThe system should use Claude Sonnet (or configured model) as the main LLM for response generation.\n\n**Implementation approach:**\n1. Add `mainClient` field to RLMController/Service\n2. Pass the Fantasy provider from app config during initialization\n3. Use mainClient in executeDirect() for actual response generation\n4. Consider model selection based on task complexity (fast/balanced/powerful)\n\n**Dependency:**\nBlocked by or related to: executeDirect placeholder fix","status":"closed","priority":0,"issue_type":"feature","created_at":"2026-01-13T17:36:04.865072-07:00","updated_at":"2026-01-13T17:52:02.805879-07:00","closed_at":"2026-01-13T17:52:02.805879-07:00","source_repo":".","labels":["architecture","critical","rlm"],"dependencies":[{"issue_id":"recurse-1x9","depends_on_id":"recurse-9s8","type":"related","created_at":"2026-01-13T17:38:46.750022-07:00","created_by":"daemon"}]}
{"id":"recurse-2ih","content_hash":"c0f26680bce89798860b55c3a8d0bf8f6f10f0ddca0daa2225fefdef66bba6a6","title":"Implement Python REPL manager","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T12:14:00.692141-07:00","updated_at":"2026-01-10T12:28:57.242846-07:00","closed_at":"2026-01-10T12:28:57.242846-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-2ih","depends_on_id":"recurse-0ol","type":"blocks","created_at":"2026-01-10T12:14:58.625019-07:00","created_by":"daemon"}]}
{"id":"recurse-2jc","content_hash":"e89478693e3f35fe0727b6cffbed3ee0f2d3a11a900dca5ac6ed7bf9fddaa795","title":"Implement decay and archival for long-term memory","description":"Per SPEC, long-term memory should implement:\n\n1. **Temporal decay**: `weight *= decay_factor ^ days_since_access`\n2. **Access amplification**: `weight *= 1 + log(access_count)`\n3. **Archive threshold**: Move nodes below threshold to archive tier\n4. **Never delete**: Archived nodes excluded from retrieval but still queryable\n\n**Current state:**\n- Decay code exists in internal/memory/evolution/decay.go\n- DecayManager and related types are implemented\n- **Not yet integrated into lifecycle or tested end-to-end**\n\n**Validation needed:**\n1. Verify decay is called during idle maintenance\n2. Verify archival threshold works correctly\n3. Verify archived nodes are excluded from normal queries","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-13T17:36:32.252132-07:00","updated_at":"2026-01-13T18:42:31.170862-07:00","closed_at":"2026-01-13T18:42:31.170862-07:00","source_repo":".","labels":["evolution","memory"],"dependencies":[{"issue_id":"recurse-2jc","depends_on_id":"recurse-dts","type":"blocks","created_at":"2026-01-13T17:38:48.909996-07:00","created_by":"daemon"}]}
{"id":"recurse-2ji","content_hash":"401d10292c4a3340fdde53f697781492666f621f5f9885e129fcf033c0ce59aa","title":"Epic: Phase 2 - Memory","description":"","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-10T12:44:33.020675-07:00","updated_at":"2026-01-11T06:21:50.535605-07:00","closed_at":"2026-01-11T06:21:50.535605-07:00","source_repo":"."}
{"id":"recurse-2jz","content_hash":"627575617e8d0bdaddcb8592807090177f3fec4ed1d3497a6ae47eea5ebe6734","title":"Implement CircuitBreaker","description":"Implement circuit breaker for recursive LLM calls.\n\n## Implementation\n- Create internal/rlm/resilience/breaker.go\n- Implement CircuitBreaker with state machine\n- Add thread-safe state transitions\n- Implement Call wrapper with breaker protection\n- Add per-model-tier breaker instances\n\n## Key Types\n```go\ntype CircuitState int\nconst (\n    StateClosed CircuitState = iota\n    StateOpen\n    StateHalfOpen\n)\n\ntype CircuitBreaker struct {\n    state           CircuitState\n    failureCount    int\n    failureThreshold int\n    recoveryTimeout time.Duration\n    lastFailureTime time.Time\n    mu              sync.Mutex\n}\n\nfunc (b *CircuitBreaker) Call(fn func() error) error\n```","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-13T19:54:38.461556-07:00","updated_at":"2026-01-14T08:34:43.254106-07:00","closed_at":"2026-01-14T08:34:43.254106-07:00","source_repo":".","labels":["implementation","resilience"],"dependencies":[{"issue_id":"recurse-2jz","depends_on_id":"recurse-rxw","type":"blocks","created_at":"2026-01-13T20:00:27.931546-07:00","created_by":"daemon"}]}
{"id":"recurse-2pe","content_hash":"3c69ecbba2ff5042832ebcb10606ef6942cc4f0c84353153813d042d9c36fee4","title":"Tests for Tree of Thoughts","description":"Comprehensive tests for ToT implementation.\n\n## Test Categories\n\n### Unit Tests\n- ThoughtNode creation and state management\n- Branch() generates correct number of children\n- EvaluateState() returns values in [0,1]\n- Backtrack() restores correct state\n- Exploration strategies traverse correctly\n\n### Property-Based Tests\n- Invariant: all explored nodes have valid parents\n- Invariant: terminal nodes are leaves\n- Invariant: value estimates are normalized\n\n### Integration Tests\n- ToT with real LLM for thought generation\n- ToT with meta-controller for evaluation\n- End-to-end reasoning improvement\n\n### Benchmarks\n- Exploration efficiency by strategy\n- Overhead vs linear decomposition","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-13T19:56:09.170973-07:00","updated_at":"2026-01-14T09:26:39.290697-07:00","closed_at":"2026-01-14T09:26:39.290697-07:00","source_repo":".","labels":["testing","tot"],"dependencies":[{"issue_id":"recurse-2pe","depends_on_id":"recurse-84a","type":"blocks","created_at":"2026-01-13T20:00:46.502515-07:00","created_by":"daemon"}]}
{"id":"recurse-2we","content_hash":"97e4e743497a4d628fa42abf39d50f6830579ed39de50312d61e1d2d236ea3ef","title":"Implement decomposition strategies (file, function, concept)","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T06:23:54.781951-07:00","updated_at":"2026-01-11T06:42:06.961939-07:00","closed_at":"2026-01-11T06:42:06.961939-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-2we","depends_on_id":"recurse-c0d","type":"blocks","created_at":"2026-01-11T06:29:26.161085-07:00","created_by":"daemon"}]}
{"id":"recurse-369","content_hash":"6d91461385d64e6d600ebed2890eed56d55863a875096ad63b203b2c3bb8b039","title":"Implement hypergraph node types and operations","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T12:44:42.17604-07:00","updated_at":"2026-01-10T12:51:05.020458-07:00","closed_at":"2026-01-10T12:51:05.020458-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-369","depends_on_id":"recurse-0yb","type":"blocks","created_at":"2026-01-10T12:45:34.69244-07:00","created_by":"daemon"}]}
{"id":"recurse-39g","content_hash":"e3233a3534f65a99ee60d33bfddb1fe98d78f411effa216eca3b8b6c4e6c9c6d","title":"Python REPL llm_call() returns placeholder when callbacks disabled","description":"The Python REPL's llm_call() function returns placeholder text when the callback handler isn't connected:\n\n```python\ndef llm_call(prompt: str, context: str = \"\", model: str = \"auto\") -\u003e str:\n    if not _callback_enabled:\n        return f\"[LLM_CALL: prompt={prompt[:50]}..., context_len={len(context)}, model={model}]\"\n```\n\nThis is correct defensive behavior, but we should:\n1. Ensure the callback handler is always connected during normal operation\n2. Add clearer error messages when LLM calls fail\n3. Document the callback protocol for testing scenarios\n\n**Related:** The SubCallRouter and CallbackHandler wiring in service.go:497-507 looks correct, but should be tested end-to-end.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T17:36:31.542456-07:00","updated_at":"2026-01-13T18:38:48.961227-07:00","closed_at":"2026-01-13T18:38:48.961227-07:00","source_repo":".","labels":["polish","repl"]}
{"id":"recurse-39i","content_hash":"455f48952cc51b6f5ab9b2c58ed1e80556e3bc01e0baee069a7d0fc937bbd773","title":"Implement CorrectionLearner","description":"Implement learning from user corrections.\n\n## Implementation\n- Create internal/rlm/learning/corrections.go\n- Define CorrectionType enum\n- Implement RecordCorrection()\n- Add pattern analysis\n- Integrate with ContinuousLearner\n\n## Key Types\n```go\ntype CorrectionType string\nconst (\n    CorrectionClassifier CorrectionType = \"classifier\"\n    CorrectionExecution  CorrectionType = \"execution\"\n    CorrectionRouting    CorrectionType = \"routing\"\n)\n\ntype UserCorrection struct {\n    Query        string\n    RLMOutput    string\n    Correction   string\n    Type         CorrectionType\n    Timestamp    time.Time\n}\n\ntype CorrectionLearner struct {\n    corrections []UserCorrection\n    learner     *ContinuousLearner\n}\n\nfunc (l *CorrectionLearner) RecordCorrection(c UserCorrection)\n```","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-13T19:58:42.063752-07:00","updated_at":"2026-01-14T11:58:48.455078-07:00","closed_at":"2026-01-14T11:58:48.455078-07:00","source_repo":".","labels":["corrections","implementation","learning"],"dependencies":[{"issue_id":"recurse-39i","depends_on_id":"recurse-7hg","type":"blocks","created_at":"2026-01-13T20:01:31.941344-07:00","created_by":"daemon"},{"issue_id":"recurse-39i","depends_on_id":"recurse-agn","type":"blocks","created_at":"2026-01-13T20:01:32.689401-07:00","created_by":"daemon"}]}
{"id":"recurse-3yb","content_hash":"2604edf7846982a8e4242b9846356f527059db7ba7943d77725ce82966c77461","title":"Implement result synthesis for combining sub-call outputs","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T06:23:54.868361-07:00","updated_at":"2026-01-11T06:43:31.644017-07:00","closed_at":"2026-01-11T06:43:31.644017-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-3yb","depends_on_id":"recurse-ys9","type":"blocks","created_at":"2026-01-11T06:29:26.273575-07:00","created_by":"daemon"},{"issue_id":"recurse-3yb","depends_on_id":"recurse-2we","type":"blocks","created_at":"2026-01-11T06:29:26.366725-07:00","created_by":"daemon"}]}
{"id":"recurse-45y","content_hash":"38fc3b816b7a31dcefbcb4b6a470c2f2dbb9432c52ff376a90aad84f93d44aed","title":"Implement ExecutionGuarantees","description":"Implement hard execution boundaries with graceful degradation.\n\n## Implementation\n- Create internal/rlm/guarantees.go\n- Implement ExecutionGuarantees with limits tracking\n- Add CanProceed() for budget/time/call checks\n- Add OnBudgetExhausted() for degradation plan\n- Integrate with Controller for enforcement\n\n## Key Types\n```go\ntype ExecutionGuarantees struct {\n    maxCostUSD        float64\n    maxDuration       time.Duration\n    maxRecursiveCalls int\n    costUsed          float64\n    deadline          time.Time\n    callsUsed         int\n}\n\nfunc (g *ExecutionGuarantees) CanProceed(estimatedCost) bool\nfunc (g *ExecutionGuarantees) OnBudgetExhausted() *DegradationPlan\n```","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-13T19:57:49.370761-07:00","updated_at":"2026-01-14T11:15:29.176648-07:00","closed_at":"2026-01-14T11:15:29.176648-07:00","source_repo":".","labels":["guarantees","implementation","reliability"],"dependencies":[{"issue_id":"recurse-45y","depends_on_id":"recurse-kum","type":"blocks","created_at":"2026-01-13T20:01:10.664009-07:00","created_by":"daemon"}]}
{"id":"recurse-5gr","content_hash":"ae3b6897237ce6fe8288fb6cc28cfc62cf1a7eca2ceec6c92ae2c339561579f8","title":"RLM Enhancement: Intelligence Layer","description":"Intelligence enhancements for better reasoning and decomposition.\n\nResearch basis:\n- Tree of Thoughts (NeurIPS 2023): 4-74% improvement on complex reasoning\n- LATS (ICML 2024): 2x tool performance via MCTS planning\n- ARTIST (Microsoft 2025): LLMs with interpreters systematically decompose\n- PREFACE (GLSVLSI 2025): RL-guided formal verification\n\nIncludes:\n- Tree of Thoughts integration\n- LATS-inspired tool orchestration\n- Proactive REPL computation detection\n- Formal verification for code changes","status":"in_progress","priority":1,"issue_type":"epic","created_at":"2026-01-13T19:53:06.753793-07:00","updated_at":"2026-01-14T08:32:07.719298-07:00","source_repo":".","labels":["intelligence","reasoning","rlm"]}
{"id":"recurse-5je","content_hash":"e8672383769ac76df15d623f93df17cf2a2309b3d3f2b572ecde5d1ce232c616","title":"Implement memory query and traversal","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T12:44:42.912788-07:00","updated_at":"2026-01-10T14:08:01.707485-07:00","closed_at":"2026-01-10T14:08:01.707485-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-5je","depends_on_id":"recurse-369","type":"blocks","created_at":"2026-01-10T12:45:35.392407-07:00","created_by":"daemon"},{"issue_id":"recurse-5je","depends_on_id":"recurse-jdf","type":"blocks","created_at":"2026-01-10T12:45:35.719807-07:00","created_by":"daemon"}]}
{"id":"recurse-65d","content_hash":"ea6f723e6d777d80b9a3058791f4797fcc118c6ae5eba46c7bce358a8967480e","title":"[SPEC] Memory Backend Abstraction Design","description":"Design specification for memory backend abstraction.\n\n## Current State\nMemoryStore directly implements SQLite operations.\n\n## Requirements\n- Define MemoryBackend interface\n- Specify SQLiteBackend implementation\n- Specify InMemoryBackend for testing\n- Design migration between backends\n- Define future extensibility (Postgres, DuckDB)\n\n## Deliverables\n- Spec document: docs/spec/memory-backend.md\n- Interface: internal/memory/backend.go\n\n## Acceptance Criteria\n- [ ] Spec covers backend interface\n- [ ] Spec covers SQLite implementation\n- [ ] Spec covers in-memory implementation\n- [ ] Spec covers migration strategy\n- [ ] Spec defines future backend options","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T19:59:36.568079-07:00","updated_at":"2026-01-13T20:33:51.46469-07:00","closed_at":"2026-01-13T20:33:51.46469-07:00","source_repo":".","labels":["architecture","memory","spec"],"dependencies":[{"issue_id":"recurse-65d","depends_on_id":"recurse-cit","type":"parent-child","created_at":"2026-01-13T20:02:29.550582-07:00","created_by":"daemon"}]}
{"id":"recurse-6f6","content_hash":"30b6cc2652713fbdfe6fd6b5e9a6b8c6f6e056a86cb3c6985fb683b6fc0df569","title":"Implement budget tracker","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T12:14:01.676211-07:00","updated_at":"2026-01-10T12:36:28.026147-07:00","closed_at":"2026-01-10T12:36:28.026147-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-6f6","depends_on_id":"recurse-0ol","type":"blocks","created_at":"2026-01-10T12:14:58.900337-07:00","created_by":"daemon"}]}
{"id":"recurse-6io","content_hash":"eb6d5becf797a7bd3b305256091d3477a4946175afe617bf22987d695839f898","title":"Track 3: Developer Experience","description":"Usability improvements: memory inspection documentation, mode selection transparency, session state persistence.","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-01-12T11:35:44.689339-07:00","updated_at":"2026-01-12T13:36:51.198562-07:00","closed_at":"2026-01-12T13:36:51.198562-07:00","source_repo":"."}
{"id":"recurse-6io.1","content_hash":"d4ee0053ce83bfa3b69e0e77fbc0f5a3f81c97fce33d385e5d39380ff79341b2","title":"Create memory inspection documentation","description":"Write user guide for memory system:\n- docs/user/memory-inspection.md\n- TUI keyboard shortcuts reference (Ctrl+M, etc.)\n- Example workflows: debugging memory issues, viewing reasoning traces\n- Screenshots of Memory Inspector panel\n- Common queries and how to run them\n\nAlso update README.md with memory section link","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-12T11:36:38.878052-07:00","updated_at":"2026-01-12T13:26:52.163242-07:00","closed_at":"2026-01-12T13:26:52.163242-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-6io.1","depends_on_id":"recurse-6io","type":"parent-child","created_at":"2026-01-12T11:36:38.878665-07:00","created_by":"daemon"},{"issue_id":"recurse-6io.1","depends_on_id":"recurse-6io.2","type":"blocks","created_at":"2026-01-12T11:37:01.672445-07:00","created_by":"daemon"}]}
{"id":"recurse-6io.2","content_hash":"96179828d4a98fe44957316a912eabea0d59ce3f1852eea12dbd8c23afa53536","title":"Add mode selection transparency to TUI","description":"Help users understand why RLM vs Direct mode was selected:\n- Show classification signals in status bar tooltip\n- Log mode selection reasoning to debug output\n- Add override hints in UI ('Force RLM: Ctrl+Shift+R')\n- Display task type classification confidence\n\nFiles: internal/tui/status_bar.go, internal/rlm/wrapper.go","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-12T11:36:39.991005-07:00","updated_at":"2026-01-12T13:22:27.241184-07:00","closed_at":"2026-01-12T13:22:27.241184-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-6io.2","depends_on_id":"recurse-6io","type":"parent-child","created_at":"2026-01-12T11:36:39.992072-07:00","created_by":"daemon"}]}
{"id":"recurse-6io.3","content_hash":"b3ab22fb0ecf41878fb443ff711f5f726b791a9127799d0e86314b0a4a09f57d","title":"Implement session state persistence","description":"Enable resume after crash/restart:\n- Checkpoint task memory state periodically (configurable interval)\n- Store last RLM context and iteration state\n- Recovery prompt on restart: 'Resume previous session?'\n- Clean up stale checkpoints on normal exit\n\nFiles: internal/memory/tiers/task.go, internal/rlm/service.go\nConfig: Add session.checkpoint section","status":"closed","priority":4,"issue_type":"feature","created_at":"2026-01-12T11:36:41.104724-07:00","updated_at":"2026-01-12T13:36:31.743028-07:00","closed_at":"2026-01-12T13:36:31.743028-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-6io.3","depends_on_id":"recurse-6io","type":"parent-child","created_at":"2026-01-12T11:36:41.105881-07:00","created_by":"daemon"}]}
{"id":"recurse-6p2","content_hash":"eb7ee6113f7a4471de6d67ee80089360d24e731f9c6e50e87a34cbc2d4f08188","title":"[SPEC] Proactive REPL Computation Design","description":"Design specification for proactive REPL computation detection.\n\n## Research Basis\nARTIST (Microsoft, 2025) demonstrates LLMs with interpreters systematically decompose complex problems.\n\n## Requirements\n- Define computation pattern detection regex\n- Specify ComputationAdvisor interface\n- Design suggestion flow for REPL approach\n- Define patterns: counting, arithmetic, sorting, filtering\n\n## Deliverables\n- Spec document: docs/spec/proactive-repl.md\n- Interface: internal/rlm/proactive.go\n\n## Acceptance Criteria\n- [ ] Spec covers pattern detection heuristics\n- [ ] Spec covers suggestion generation\n- [ ] Spec covers integration with orchestrator\n- [ ] Patterns cover common computational queries","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T19:56:12.510471-07:00","updated_at":"2026-01-13T21:01:29.940972-07:00","closed_at":"2026-01-13T21:01:29.940972-07:00","source_repo":".","labels":["proactive","repl","spec"],"dependencies":[{"issue_id":"recurse-6p2","depends_on_id":"recurse-5gr","type":"parent-child","created_at":"2026-01-13T20:02:08.563893-07:00","created_by":"daemon"}]}
{"id":"recurse-6qp","content_hash":"419f343a6ab3c9feddd57ce34dedd190d0a8cb8761bb24ac11ed5b037c1a8827","title":"Implement HybridSearch in MemoryStore","description":"Add hybrid keyword + semantic search to memory store.\n\n## Implementation\n- Add node_embeddings table with SQLite vec extension\n- Implement VectorSearch for embedding-based retrieval\n- Implement HybridSearch combining FTS5 + vectors\n- Add reciprocal rank fusion for result merging\n- Update CreateNode to compute embeddings optionally\n\n## Schema Addition\n```sql\nCREATE VIRTUAL TABLE node_embeddings USING vec0(\n    node_id TEXT PRIMARY KEY,\n    embedding FLOAT[1024]\n);\n```\n\n## Key Functions\n```go\nfunc (s *Store) VectorSearch(ctx, embedding, opts) ([]Node, error)\nfunc (s *Store) HybridSearch(ctx, query, opts) ([]Node, error)\nfunc (s *Store) reciprocalRankFusion(keyword, semantic, alpha) []Node\n```","status":"closed","priority":0,"issue_type":"feature","created_at":"2026-01-13T19:54:34.684158-07:00","updated_at":"2026-01-14T08:03:54.262193-07:00","closed_at":"2026-01-14T08:03:54.262193-07:00","source_repo":".","labels":["embeddings","implementation","memory"],"dependencies":[{"issue_id":"recurse-6qp","depends_on_id":"recurse-eim","type":"blocks","created_at":"2026-01-13T20:00:24.529971-07:00","created_by":"daemon"},{"issue_id":"recurse-6qp","depends_on_id":"recurse-qm2","type":"blocks","created_at":"2026-01-13T20:00:25.213822-07:00","created_by":"daemon"}]}
{"id":"recurse-6qq","content_hash":"9dcb680175fd019b3030f08427a56531409db802941fd2a8d2890e1c2c473de4","title":"Tests for Prompt Caching","description":"Tests for prompt caching implementation.\n\n## Test Categories\n\n### Unit Tests\n- PrepareCacheablePrompt structures correctly\n- Cache prefix registry lookup\n- Cache control blocks added properly\n- Metrics updated on cache hit/miss\n\n### Integration Tests\n- Actual API calls with caching\n- Cache hit verification via response headers\n- Cost comparison: cached vs uncached\n\n### Benchmarks\n- Latency: cached vs uncached (expect 85% reduction)\n- Cost tracking: cached vs uncached (expect 90% reduction)","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-13T19:54:37.204303-07:00","updated_at":"2026-01-14T08:26:06.548504-07:00","closed_at":"2026-01-14T08:26:06.548504-07:00","source_repo":".","labels":["caching","testing"],"dependencies":[{"issue_id":"recurse-6qq","depends_on_id":"recurse-mld","type":"blocks","created_at":"2026-01-13T20:00:27.21217-07:00","created_by":"daemon"}]}
{"id":"recurse-77r","content_hash":"e9db61354740546ae216d13bd098116e69be86973e71baf54826cc5427430dfb","title":"Implement VerificationChain","description":"Implement formal verification for code changes.\n\n## Implementation\n- Create internal/rlm/verify/chain.go\n- Implement GeneratePreconditions() from docstrings/comments\n- Implement GeneratePostconditions() for expected state\n- Add buildVerificationCode() for CPMpy model\n- Implement Verify() via REPL execution\n\n## Key Types\n```go\ntype VerificationChain struct {\n    repl   *PythonREPL\n    solver ConstraintSolver\n}\n\ntype Constraint struct {\n    Type       string\n    Expression string\n    Confidence float64\n}\n\nfunc (c *VerificationChain) GeneratePreconditions(ctx, change) ([]Constraint, error)\nfunc (c *VerificationChain) Verify(ctx, constraints, code) (*VerificationResult, error)\n```","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-13T19:56:15.241642-07:00","updated_at":"2026-01-13T19:56:15.241642-07:00","source_repo":".","labels":["formal","implementation","verification"],"dependencies":[{"issue_id":"recurse-77r","depends_on_id":"recurse-r26","type":"blocks","created_at":"2026-01-13T20:01:05.758479-07:00","created_by":"daemon"}]}
{"id":"recurse-7hg","content_hash":"3c0f23b4249f90e586fe363ad6358e519a15b19b94cc4fe23a7832f212fdf688","title":"[SPEC] User Correction Learning Design","description":"Design specification for learning from user corrections.\n\n## Research Basis\nRLHF and ToTRL (2025) show learning from feedback significantly improves reasoning.\n\n## Requirements\n- Define CorrectionType enum\n- Specify UserCorrection structure\n- Design pattern analysis from corrections\n- Define adjustment suggestions\n- Specify integration with ContinuousLearner\n\n## Deliverables\n- Spec document: docs/spec/user-corrections.md\n- Interface: internal/rlm/learning/corrections.go\n\n## Acceptance Criteria\n- [ ] Spec covers correction types\n- [ ] Spec covers pattern analysis\n- [ ] Spec covers adjustment suggestions\n- [ ] Spec defines integration with learner","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T19:58:41.433046-07:00","updated_at":"2026-01-13T20:33:53.55242-07:00","closed_at":"2026-01-13T20:33:53.55242-07:00","source_repo":".","labels":["corrections","learning","spec"],"dependencies":[{"issue_id":"recurse-7hg","depends_on_id":"recurse-kes","type":"parent-child","created_at":"2026-01-13T20:02:27.267709-07:00","created_by":"daemon"}]}
{"id":"recurse-7kz","content_hash":"f8ffe86bcdb039dfc0ee2feb9ca3ab61d19b2364d4910d1ce1e028db4a2732ea","title":"Add rlm subcommand for direct RLM execution","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T07:13:26.990101-07:00","updated_at":"2026-01-11T07:16:49.95934-07:00","closed_at":"2026-01-11T07:16:49.95934-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-7kz","depends_on_id":"recurse-zhb","type":"blocks","created_at":"2026-01-11T07:13:43.174175-07:00","created_by":"daemon"}]}
{"id":"recurse-7wg","content_hash":"9bc5b5cbb2ede6efe132c89a9c9c2cadce6f9835abf1c9732a97b897cc87772c","title":"Implement LearnedRouter","description":"Implement learned model routing with cascading.\n\n## Implementation\n- Create internal/rlm/routing/learned.go\n- Define ModelProfile with strengths and costs\n- Implement Route() with feature-based selection\n- Add CascadeRoute() for confidence-based escalation\n- Integrate with ContinuousLearner for adjustments\n\n## Key Types\n```go\ntype LearnedRouter struct {\n    modelProfiles       map[string]ModelProfile\n    learner             *ContinuousLearner\n    confidenceThreshold float64\n    cascadeOrder        []string\n}\n\ntype ModelProfile struct {\n    Strengths    []string\n    CostPer1K    float64\n    QualityBase  float64\n}\n\nfunc (r *LearnedRouter) Route(query, context, costSensitivity) RoutingDecision\nfunc (r *LearnedRouter) CascadeRoute(ctx, query, context) (*CascadeResult, error)\n```\n\n## Expected Impact\n85% cost reduction maintaining 95% quality.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-13T19:58:40.013952-07:00","updated_at":"2026-01-14T11:54:20.083009-07:00","closed_at":"2026-01-14T11:54:20.083009-07:00","source_repo":".","labels":["implementation","learning","routing"],"dependencies":[{"issue_id":"recurse-7wg","depends_on_id":"recurse-dcn","type":"blocks","created_at":"2026-01-13T20:01:29.736883-07:00","created_by":"daemon"},{"issue_id":"recurse-7wg","depends_on_id":"recurse-agn","type":"blocks","created_at":"2026-01-13T20:01:30.482159-07:00","created_by":"daemon"}]}
{"id":"recurse-84a","content_hash":"905a5c11e860c6b560367232b7364f5da309ca9cab7ae55892436d4c53dbd6bd","title":"Implement ToT Exploration Strategies","description":"Implement exploration strategies for Tree of Thoughts.\n\n## Implementation\n- Create internal/rlm/tot/strategies.go\n- Implement BFS exploration\n- Implement DFS exploration\n- Implement best-first (value-guided) exploration\n- Add pruning based on value threshold\n- Add depth limiting\n\n## Key Functions\n```go\nfunc (t *ThoughtTree) ExploreWithBFS(ctx, goal) (*ThoughtNode, error)\nfunc (t *ThoughtTree) ExploreWithDFS(ctx, goal) (*ThoughtNode, error)\nfunc (t *ThoughtTree) ExploreWithBestFirst(ctx, goal) (*ThoughtNode, error)\n```\n\n## Expected Impact\n4-74% improvement on complex reasoning tasks.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-13T19:56:08.477014-07:00","updated_at":"2026-01-14T09:18:15.588054-07:00","closed_at":"2026-01-14T09:18:15.588054-07:00","source_repo":".","labels":["implementation","reasoning","tot"],"dependencies":[{"issue_id":"recurse-84a","depends_on_id":"recurse-vst","type":"blocks","created_at":"2026-01-13T20:00:45.115899-07:00","created_by":"daemon"},{"issue_id":"recurse-84a","depends_on_id":"recurse-9ao","type":"blocks","created_at":"2026-01-13T20:00:45.812205-07:00","created_by":"daemon"}]}
{"id":"recurse-8fa","content_hash":"a0f89d434ed82ce273c2e53071643951b998d9c873007002b18cbaf08ba0bdcc","title":"Epic: Phase 5 - Integration","description":"","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-11T06:59:31.194391-07:00","updated_at":"2026-01-11T07:09:27.008922-07:00","closed_at":"2026-01-11T07:09:27.008922-07:00","source_repo":"."}
{"id":"recurse-8yp","content_hash":"8ca00ecbd905a2a66264ccf1e2abbe7726e0e9c8bf2c86cd70605022c1bc0ecb","title":"Implement Confidence-Weighted Synthesis","description":"Implement confidence-weighted result aggregation.\n\n## Implementation\n- Create internal/rlm/synthesize/weighted.go\n- Add Confidence field to RecursiveResult\n- Implement weight normalization\n- Add SynthesizeWeighted() with weighted prompt\n- Integrate with existing synthesizer\n\n## Key Types\n```go\ntype RecursiveResult struct {\n    Content        string\n    Confidence     float64\n    ReasoningTrace []string\n    Cost           float64\n}\n\nfunc SynthesizeWeighted(results []RecursiveResult) SynthesisResult\n```","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-13T19:57:51.425558-07:00","updated_at":"2026-01-14T11:23:40.261764-07:00","closed_at":"2026-01-14T11:23:40.261764-07:00","source_repo":".","labels":["implementation","reliability","synthesis"],"dependencies":[{"issue_id":"recurse-8yp","depends_on_id":"recurse-aa2","type":"blocks","created_at":"2026-01-13T20:01:12.122167-07:00","created_by":"daemon"}]}
{"id":"recurse-8yz","content_hash":"6e2dcbf8d2f281af671aaf9f9230896707d054dc5dfbaceb07e9f826885cedf2","title":"[SPEC] Async Recursive Execution Design","description":"Design specification for async recursive call execution.\n\n## Research Basis\nRLM paper explicitly notes \"lack of asynchrony can cause each query to range from a few seconds to several minutes\" as a key limitation.\n\n## Requirements\n- Define async execution model for parallel recursive calls\n- Specify speculative execution semantics (race, cancel losers)\n- Define error handling for partial failures\n- Specify concurrency limits and budget awareness\n- Define interaction with existing synchronous code paths\n\n## Deliverables\n- Spec document: docs/spec/async-execution.md\n- Interface definitions in internal/rlm/async_executor.go\n- Integration plan with existing Controller\n\n## Acceptance Criteria\n- [ ] Spec covers parallel execution of independent operations\n- [ ] Spec covers speculative execution with cancellation\n- [ ] Spec covers partial failure handling\n- [ ] Spec defines budget-aware parallelism\n- [ ] Interface definitions reviewed and approved","notes":"Spec completed at docs/design/async-execution.md. Covers:\n- ExecutionPlan type with dependency graph\n- AsyncExecutor interface (ExecutePlan, ExecuteParallel, ExecuteSpeculative)\n- Budget-aware parallelism via effectiveParallelism()\n- Speculative execution with automatic cancellation\n- Integration with existing Controller.executeDecompose()\n- Error handling with partial failure strategies\n- Observability (metrics, tracing)\n- Migration path (opt-in → default → speculation)\n- Testing strategy (unit, concurrency, integration)","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-13T19:54:31.610429-07:00","updated_at":"2026-01-13T20:07:48.286378-07:00","closed_at":"2026-01-13T20:07:48.286378-07:00","source_repo":".","labels":["async","critical","spec"],"dependencies":[{"issue_id":"recurse-8yz","depends_on_id":"recurse-038","type":"parent-child","created_at":"2026-01-13T20:02:04.154118-07:00","created_by":"daemon"}]}
{"id":"recurse-8z6","content_hash":"92a5a62891591dda8b943cd09c18c52f8e7af04488d2b0931cd0382cddcafeb9","title":"[SPEC] Context Compression Design","description":"Design specification for two-stage context compression.\n\n## Research Basis\nKVzip (SNU, 2025) achieves 3-4x memory compression with 2x latency reduction.\n\n## Requirements\n- Define ContextCompressor interface\n- Specify extractive compression (sentence scoring)\n- Specify abstractive compression (LLM summarization)\n- Design two-stage pipeline with thresholds\n- Define compression quality metrics\n\n## Deliverables\n- Spec document: docs/spec/context-compression.md\n- Interface: internal/rlm/compress/compressor.go\n\n## Acceptance Criteria\n- [ ] Spec covers extractive sentence selection\n- [ ] Spec covers abstractive summarization\n- [ ] Spec covers two-stage pipeline\n- [ ] Spec defines compression ratio targets\n- [ ] Spec defines quality preservation metrics","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-13T19:57:01.691638-07:00","updated_at":"2026-01-13T20:27:41.191525-07:00","closed_at":"2026-01-13T20:27:41.191525-07:00","source_repo":".","labels":["compression","performance","spec"],"dependencies":[{"issue_id":"recurse-8z6","depends_on_id":"recurse-qdb","type":"parent-child","created_at":"2026-01-13T20:02:10.023315-07:00","created_by":"daemon"}]}
{"id":"recurse-8zz","content_hash":"febb4870d42246ca86a9cd3b7c5777d863fffda1b078dd0a32e4bf4ca37a9dc3","title":"Epic: Phase 3 - RLM Orchestration","description":"","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-11T06:23:49.215417-07:00","updated_at":"2026-01-11T06:45:37.111274-07:00","closed_at":"2026-01-11T06:45:37.111274-07:00","source_repo":"."}
{"id":"recurse-98r","content_hash":"4af8b2d7f70fbbe7dc3c036262c80e68f47c8e519f31e7ae47976a1fb7d45af2","title":"Implement LATSOrchestrator","description":"Implement LATS-inspired tool orchestration with MCTS.\n\n## Implementation\n- Create internal/rlm/lats/orchestrator.go\n- Implement Plan() for initial tool sequence generation\n- Implement MCTS with UCB1 node selection\n- Add Expand() for generating alternative actions\n- Add Simulate() for outcome estimation\n- Add Backpropagate() for value updates\n\n## Key Types\n```go\ntype LATSOrchestrator struct {\n    explorationWeight float64 // UCB1 constant\n    maxRollouts       int\n    maxDepth          int\n}\n\ntype ToolPlan struct {\n    Goal         string\n    Steps        []ToolStep\n    Dependencies map[int][]int\n    Confidence   float64\n}\n\nfunc (o *LATSOrchestrator) Plan(ctx, query, tools) (*ToolPlan, error)\n```\n\n## Expected Impact\n2x tool use performance improvement.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-13T19:56:10.466251-07:00","updated_at":"2026-01-14T09:34:21.729691-07:00","closed_at":"2026-01-14T09:34:21.729691-07:00","source_repo":".","labels":["implementation","lats","tools"],"dependencies":[{"issue_id":"recurse-98r","depends_on_id":"recurse-0ef","type":"blocks","created_at":"2026-01-13T20:00:47.184616-07:00","created_by":"daemon"}]}
{"id":"recurse-9ao","content_hash":"c89b551fa06c1162c0dcf785919b856a5c6868e80eebb814c1949503570515c7","title":"Implement ThoughtTree Core","description":"Implement core Tree of Thoughts data structures and operations.\n\n## Implementation\n- Create internal/rlm/tot/tree.go\n- Implement ThoughtNode with state management\n- Implement ThoughtTree with root and traversal\n- Add Branch() for generating child thoughts\n- Add EvaluateState() for LLM-based scoring\n- Add Backtrack() for exploration recovery\n\n## Key Types\n```go\ntype ThoughtNode struct {\n    ID            string\n    Thought       string\n    State         map[string]any\n    Children      []*ThoughtNode\n    ValueEstimate float64\n    IsTerminal    bool\n    Parent        *ThoughtNode\n}\n\ntype ToTConfig struct {\n    MaxBranches    int\n    MaxDepth       int\n    ValueThreshold float64\n    Strategy       string // \"bfs\" | \"dfs\" | \"best_first\"\n}\n\ntype ThoughtTree struct {\n    config ToTConfig\n    root   *ThoughtNode\n}\n```","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-13T19:56:07.796301-07:00","updated_at":"2026-01-14T09:05:44.328417-07:00","closed_at":"2026-01-14T09:05:44.328417-07:00","source_repo":".","labels":["implementation","reasoning","tot"],"dependencies":[{"issue_id":"recurse-9ao","depends_on_id":"recurse-vst","type":"blocks","created_at":"2026-01-13T20:00:44.385754-07:00","created_by":"daemon"}]}
{"id":"recurse-9ke","content_hash":"0da13e0f1094b25953d74a44c1f790c754117413cfe1b932581acde78185a97a","title":"Tests for Continuous Learning","description":"Tests for continuous learning implementation.\n\n## Test Categories\n\n### Unit Tests\n- RecordOutcome updates adjustments\n- Success reinforces routing\n- Failure discourages routing\n- GetRoutingAdjustment returns correct values\n\n### Integration Tests\n- Persistence across sessions\n- Learning loop with real outcomes\n\n### Property-Based Tests\n- Invariant: adjustments bounded\n- Invariant: consistent with outcomes","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T19:58:38.522987-07:00","updated_at":"2026-01-14T11:47:58.121514-07:00","closed_at":"2026-01-14T11:47:58.121514-07:00","source_repo":".","labels":["learning","testing"],"dependencies":[{"issue_id":"recurse-9ke","depends_on_id":"recurse-agn","type":"blocks","created_at":"2026-01-13T20:01:28.989696-07:00","created_by":"daemon"}]}
{"id":"recurse-9qw","content_hash":"dac0b69062482d1ed0715d960f76389d1fa830e071246626db77626cbd54666c","title":"Add memory inspector TUI panel","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-10T12:44:43.976623-07:00","updated_at":"2026-01-11T06:21:31.895594-07:00","closed_at":"2026-01-11T06:21:31.895594-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-9qw","depends_on_id":"recurse-0i9","type":"blocks","created_at":"2026-01-10T12:45:36.786977-07:00","created_by":"daemon"}]}
{"id":"recurse-9s8","content_hash":"7783849a5dc9d2416e3101399e1982be46521f9c79e181f88c8ec7ebfa0e07ea","title":"CRITICAL: executeDirect returns task text without calling LLM","description":"The `executeDirect` function in `internal/rlm/controller.go:310-318` is a placeholder that returns the task text without actually calling an LLM to generate a response.\n\n**Current behavior (lines 310-318):**\n```go\nfunc (c *Controller) executeDirect(ctx context.Context, state meta.State) (string, int, error) {\n    tokens := estimateTokens(state.Task) * 2\n    response := state.Task  // Just returns the task!\n    return response, tokens, nil\n}\n```\n\n**Expected behavior:**\nWhen the meta-controller decides `DIRECT`, the system should call the main LLM (e.g., Claude Sonnet) to generate an actual response.\n\n**Impact:**\n- RLM cannot generate meaningful responses\n- The entire orchestration system is non-functional for end users\n- Running `./recurse rlm \"What is 2+2?\"` returns \"What is 2+2?\" instead of an answer\n\n**Fix required:**\n1. Add a main LLM client to the Controller\n2. Implement actual LLM call in executeDirect\n3. Consider using the existing Fantasy provider from the app config","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-13T17:36:02.589394-07:00","updated_at":"2026-01-13T17:51:31.535394-07:00","closed_at":"2026-01-13T17:51:31.535394-07:00","source_repo":".","labels":["blocking","critical","rlm"]}
{"id":"recurse-a95","content_hash":"191aac13f9b852ea961471598d017c297b98f0741a17ad49e20d571640d545ae","title":"Tests for Modular Orchestrator","description":"Update and verify tests after orchestrator refactoring.\n\n## Test Categories\n\n### Unit Tests\n- Each module tests independently\n- Interface contracts verified\n- No import cycles\n\n### Integration Tests\n- End-to-end orchestration unchanged\n- All existing tests pass\n\n### Regression Tests\n- Benchmark latency unchanged\n- Cost tracking unchanged","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T19:59:33.697763-07:00","updated_at":"2026-01-14T12:29:06.441239-07:00","closed_at":"2026-01-14T12:29:06.441239-07:00","source_repo":".","labels":["architecture","testing"],"dependencies":[{"issue_id":"recurse-a95","depends_on_id":"recurse-dl7","type":"blocks","created_at":"2026-01-13T20:01:44.598515-07:00","created_by":"daemon"}]}
{"id":"recurse-aa2","content_hash":"7896fd6a3ef1c4393f39d2bb717a9c8640988bdd41d7b94f5e1ec6848d3e121b","title":"[SPEC] Confidence-Weighted Synthesis Design","description":"Design specification for confidence-weighted result synthesis.\n\n## Research Basis\nRLM paper notes quality variance in recursive call results. Weighting by confidence improves aggregation.\n\n## Requirements\n- Define RecursiveResult with confidence field\n- Specify confidence estimation methods\n- Design weighted synthesis prompt\n- Define weight normalization\n- Specify integration with existing synthesizer\n\n## Deliverables\n- Spec document: docs/spec/weighted-synthesis.md\n- Interface: internal/rlm/synthesize/weighted.go\n\n## Acceptance Criteria\n- [ ] Spec covers confidence tracking per result\n- [ ] Spec covers weight computation\n- [ ] Spec covers weighted prompt construction\n- [ ] Spec defines fallback for low-confidence results","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-13T19:57:50.772164-07:00","updated_at":"2026-01-13T20:27:39.032326-07:00","closed_at":"2026-01-13T20:27:39.032326-07:00","source_repo":".","labels":["reliability","spec","synthesis"],"dependencies":[{"issue_id":"recurse-aa2","depends_on_id":"recurse-10h","type":"parent-child","created_at":"2026-01-13T20:02:25.007399-07:00","created_by":"daemon"}]}
{"id":"recurse-agn","content_hash":"a0a0974f30002df799aaf95f95ea2acbadf4613164045ea877684b6d09ac13f7","title":"Implement ContinuousLearner","description":"Implement outcome-based learning loop.\n\n## Implementation\n- Create internal/rlm/learning/learner.go\n- Implement RecordOutcome() with signal extraction\n- Add routing adjustments map\n- Add strategy preferences map\n- Implement GetRoutingAdjustment() for routing\n- Add persistence to SQLite\n\n## Key Types\n```go\ntype ExecutionOutcome struct {\n    Query           string\n    QueryFeatures   QueryFeatures\n    StrategyUsed    string\n    ModelUsed       string\n    DepthReached    int\n    ToolsUsed       []string\n    Success         bool\n    QualityScore    float64\n    Cost            float64\n    LatencyMS       int64\n}\n\ntype ContinuousLearner struct {\n    routingAdjustments  map[string]float64\n    strategyPreferences map[string]float64\n    learningRate        float64\n    persistence         *sql.DB\n}\n\nfunc (l *ContinuousLearner) RecordOutcome(outcome ExecutionOutcome)\nfunc (l *ContinuousLearner) GetRoutingAdjustment(queryType, model) float64\n```","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-13T19:58:37.769613-07:00","updated_at":"2026-01-14T11:41:56.843242-07:00","closed_at":"2026-01-14T11:41:56.843242-07:00","source_repo":".","labels":["adaptation","implementation","learning"],"dependencies":[{"issue_id":"recurse-agn","depends_on_id":"recurse-xwr","type":"blocks","created_at":"2026-01-13T20:01:28.262935-07:00","created_by":"daemon"}]}
{"id":"recurse-asp","content_hash":"a7ab56b8161dcc2fbb0f091040d9b5be1dad8dfd826bdafce393e1f2b614b5a1","title":"Implement consolidation algorithms (avoid brevity bias)","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T06:46:49.730229-07:00","updated_at":"2026-01-11T06:52:53.836728-07:00","closed_at":"2026-01-11T06:52:53.836728-07:00","source_repo":"."}
{"id":"recurse-b0y","content_hash":"b9a203857a01977e78c3346baa6803bcc60dbddabf5f98dc8f1e4db0caf713b8","title":"Track 1: Complete Research Integration","description":"Wire remaining research paper concepts into implementation: LLM classification fallback, meta-evolution proposals, diff capture in reasoning traces. Based on RLM, HGMem, ACE, and MemEvolve papers.","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-12T11:35:42.460008-07:00","updated_at":"2026-01-12T12:46:32.494863-07:00","closed_at":"2026-01-12T12:46:32.494863-07:00","source_repo":"."}
{"id":"recurse-b0y.1","content_hash":"c5b17fca37e9c0377e890c0f19edc659824d08ddf4f05615ed57a2acd967665d","title":"Research: Deep-dive MemEvolve paper for meta-evolution implementation","description":"Read arxiv 2512.18746 in detail. Document:\n- Exact algorithm for detecting pattern emergence\n- Proposal generation criteria\n- User approval workflow patterns\n- Success metrics from paper\n\nOutput: Design doc in docs/design/meta-evolution.md","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-12T11:36:01.259843-07:00","updated_at":"2026-01-12T12:32:32.395446-07:00","closed_at":"2026-01-12T12:32:32.395446-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-b0y.1","depends_on_id":"recurse-b0y","type":"parent-child","created_at":"2026-01-12T11:36:01.260957-07:00","created_by":"daemon"}]}
{"id":"recurse-b0y.2","content_hash":"8fc93ca0ef3b0f52749bf674124fc3c96cb3389c95459b06ca0446b21847b26d","title":"Complete diff capture in reasoning traces","description":"Implement SPEC.md section 5.3 Git Integration:\n- Capture pre/post diffs when action completes\n- Store as snippet nodes linked to action via 'produces' hyperedge\n- Enable 'what changed for this decision' queries\n\nFiles: internal/memory/reasoning/trace.go, persistent_trace.go\nTests: Add integration tests with real git operations","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-12T11:36:02.379366-07:00","updated_at":"2026-01-12T11:50:51.604028-07:00","closed_at":"2026-01-12T11:50:51.604028-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-b0y.2","depends_on_id":"recurse-b0y","type":"parent-child","created_at":"2026-01-12T11:36:02.380724-07:00","created_by":"daemon"}]}
{"id":"recurse-b0y.3","content_hash":"3d0de7e1a63dd5844fe554dd591c78fbc71532ff67710240c506607ea5688b77","title":"Wire LLM-based task classification fallback","description":"Use Claude Haiku for low-confidence (\u003c70%) task classifications.\n\nDesign exists in docs/design/task-classification.md Phase 4.\n\nImplementation:\n- Add LLM fallback path in classifier.go\n- Use meta-controller's Haiku instance\n- Only invoke on confidence \u003c 0.7\n- Cache classification results\n\nTests: Add test cases for ambiguous queries","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-12T11:36:03.472714-07:00","updated_at":"2026-01-12T12:22:06.388225-07:00","closed_at":"2026-01-12T12:22:06.388225-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-b0y.3","depends_on_id":"recurse-b0y","type":"parent-child","created_at":"2026-01-12T11:36:03.474115-07:00","created_by":"daemon"}]}
{"id":"recurse-b0y.4","content_hash":"fd1de9858ca4146056e68d936bc5c83dc43047e7b2902d625639280691bf7123","title":"Surface meta-evolution proposals to user","description":"Implement MemEvolve-inspired architecture adaptation:\n- Analyze evolution_log for repeated node type mismatches\n- Generate proposals for new subtypes when patterns emerge\n- Present to user via TUI Memory Inspector for approval\n- Apply approved changes to schema\n\nFiles: internal/memory/evolution/meta.go, lifecycle.go\nTUI: Add proposal dialog in tui/components/dialogs/memory/","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-12T11:36:11.661155-07:00","updated_at":"2026-01-12T12:42:55.558681-07:00","closed_at":"2026-01-12T12:42:55.558681-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-b0y.4","depends_on_id":"recurse-b0y","type":"parent-child","created_at":"2026-01-12T11:36:11.663002-07:00","created_by":"daemon"},{"issue_id":"recurse-b0y.4","depends_on_id":"recurse-b0y.1","type":"blocks","created_at":"2026-01-12T11:36:11.664469-07:00","created_by":"daemon"}]}
{"id":"recurse-b0y.5","content_hash":"8da14bb22bab805e99e918abaf55b57941d33f3f35d3dee86c610471ded834a3","title":"Research: Review ACE paper for brevity bias prevention patterns","description":"Read arxiv 2510.04618 to verify current consolidation implementation:\n- Check if consolidate.go properly preserves source links\n- Identify any missing ACE patterns not yet implemented\n- Document findings in docs/design/context-evolution.md\n\nThis informs potential improvements to memory evolution.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-12T11:36:52.027783-07:00","updated_at":"2026-01-12T12:45:59.69939-07:00","closed_at":"2026-01-12T12:45:59.69939-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-b0y.5","depends_on_id":"recurse-b0y","type":"parent-child","created_at":"2026-01-12T11:36:52.028795-07:00","created_by":"daemon"}]}
{"id":"recurse-b10","content_hash":"872581bb6aa0a07c8971d188b20aafcfc9d63f399c49dab08e01ac16b14806f6","title":"Track 2: Production Hardening","description":"Reliability improvements for daily driver use: REPL resource monitoring, TUI test coverage, error recovery in RLM loop.","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-12T11:35:43.569968-07:00","updated_at":"2026-01-12T13:13:58.773868-07:00","closed_at":"2026-01-12T13:13:58.773868-07:00","source_repo":"."}
{"id":"recurse-b10.1","content_hash":"43b4b5c47620247ad77bed1f864d50b27baa4941253dab8e6332f417c5421a31","title":"Add TUI test coverage for critical components","description":"Add tests for untested TUI components. Priority order:\n1. dialogs/permissions - security-relevant\n2. dialogs/reasoning - core feature visibility  \n3. dialogs/filepicker - user interaction\n4. page/chat - main interaction surface\n\nTarget: \u003e80% coverage on these 4 components\nPattern: Follow existing tests in dialogs/memory/, dialogs/models/","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-12T11:36:24.790077-07:00","updated_at":"2026-01-12T12:58:02.185003-07:00","closed_at":"2026-01-12T12:58:02.185003-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-b10.1","depends_on_id":"recurse-b10","type":"parent-child","created_at":"2026-01-12T11:36:24.791162-07:00","created_by":"daemon"}]}
{"id":"recurse-b10.2","content_hash":"b71cd654f12066fb9e3366e615f3bbb8431dd2df4128e353b737f78ffec23e68","title":"Implement REPL resource monitoring","description":"Harden REPL sandbox with hard resource limits:\n- Memory: Use resource module or cgroups for hard limits (not advisory)\n- CPU: Track CPU time per execution\n- Graceful termination on limit breach with error context\n- Add metrics to budget tracker\n\nFiles: internal/rlm/repl/sandbox.go, manager.go\nConfig: Add to repl.sandbox section in config schema","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-12T11:36:25.891484-07:00","updated_at":"2026-01-12T13:04:09.067435-07:00","closed_at":"2026-01-12T13:04:09.067435-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-b10.2","depends_on_id":"recurse-b10","type":"parent-child","created_at":"2026-01-12T11:36:25.892455-07:00","created_by":"daemon"}]}
{"id":"recurse-b10.3","content_hash":"725bb6ab0b98df1718502c66112a2caea45e57882b4425d4a1503d26c0d033c3","title":"Add error recovery in RLM loop","description":"Improve RLM resilience when REPL errors occur:\n- Retry with error context in prompt (1 retry max)\n- Graceful degradation to direct mode on repeated failure\n- Track error patterns in evolution_log for meta-analysis\n- Surface recovery actions to user\n\nFiles: internal/rlm/controller.go, orchestrator.go","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-12T11:36:27.000396-07:00","updated_at":"2026-01-12T13:11:18.300297-07:00","closed_at":"2026-01-12T13:11:18.300297-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-b10.3","depends_on_id":"recurse-b10","type":"parent-child","created_at":"2026-01-12T11:36:27.001685-07:00","created_by":"daemon"},{"issue_id":"recurse-b10.3","depends_on_id":"recurse-b10.2","type":"blocks","created_at":"2026-01-12T11:36:27.002851-07:00","created_by":"daemon"},{"issue_id":"recurse-b10.3","depends_on_id":"recurse-b0y.3","type":"blocks","created_at":"2026-01-12T11:37:02.81949-07:00","created_by":"daemon"}]}
{"id":"recurse-b10.4","content_hash":"dc12a9c28267c2dbda84e45ff44774154e959505124ce6fbd796ecda94f6dda3","title":"Audit memory query performance","description":"Profile hypergraph queries for performance issues:\n- Identify full table scans in query.go (455 LOC)\n- Benchmark common query patterns\n- Propose composite indices for hot paths\n- Consider LRU caching for repeated queries\n\nOutput: Performance report with recommendations\nFiles: internal/memory/hypergraph/query.go","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-12T11:36:53.117276-07:00","updated_at":"2026-01-12T13:13:47.062995-07:00","closed_at":"2026-01-12T13:13:47.062995-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-b10.4","depends_on_id":"recurse-b10","type":"parent-child","created_at":"2026-01-12T11:36:53.118275-07:00","created_by":"daemon"}]}
{"id":"recurse-b5h","content_hash":"99ebb83ac106d2e5eaf3e7394233cf4ecf7a646fcda2e18d61ca7d18258eca28","title":"Implement MemoryBackend Interface","description":"Implement memory backend abstraction.\n\n## Implementation\n- Create internal/memory/backend.go\n- Define MemoryBackend interface\n- Refactor Store to use backend interface\n- Implement SQLiteBackend\n- Implement InMemoryBackend for testing\n\n## Key Types\n```go\ntype MemoryBackend interface {\n    CreateNode(ctx, node) (string, error)\n    GetNode(ctx, id) (*Node, error)\n    UpdateNode(ctx, id, updates) error\n    DeleteNode(ctx, id) error\n    CreateEdge(ctx, edge) (string, error)\n    GetEdge(ctx, id) (*Hyperedge, error)\n    Search(ctx, query, opts) ([]Node, error)\n    VectorSearch(ctx, embedding, opts) ([]Node, error)\n    Close() error\n}\n\ntype SQLiteBackend struct { db *sql.DB }\ntype InMemoryBackend struct { nodes map[string]Node }\n```","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-13T19:59:37.197586-07:00","updated_at":"2026-01-14T12:06:03.898209-07:00","closed_at":"2026-01-14T12:06:03.898209-07:00","source_repo":".","labels":["architecture","implementation","memory"],"dependencies":[{"issue_id":"recurse-b5h","depends_on_id":"recurse-65d","type":"blocks","created_at":"2026-01-13T20:01:46.760843-07:00","created_by":"daemon"}]}
{"id":"recurse-bab","content_hash":"df69bff1cd4e8c38a53053639ddb2ba04731a027ec23e7d064d3c57784c0ba74","title":"[SPEC] Prompt Caching Strategy Design","description":"Design specification for Claude prompt caching optimization.\n\n## Research Basis\nClaude's prompt caching can reduce costs by 90% and latency by 85% for repeated context.\n\n## Requirements\n- Define cache-aware prompt structure\n- Specify cache prefix registry for common contexts\n- Design recursive call structuring for cache hits\n- Define cache metrics tracking\n- Specify integration with existing API client\n\n## Deliverables\n- Spec document: docs/spec/prompt-caching.md\n- Interface: internal/rlm/cache/cache.go\n\n## Acceptance Criteria\n- [ ] Spec covers cache-aware prompt preparation\n- [ ] Spec covers optimal ordering (stable first, variable last)\n- [ ] Spec covers cache prefix registry\n- [ ] Spec covers metrics for cache hit rate","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-13T19:54:35.925073-07:00","updated_at":"2026-01-13T20:14:47.77657-07:00","closed_at":"2026-01-13T20:14:47.77657-07:00","source_repo":".","labels":["caching","cost","spec"],"dependencies":[{"issue_id":"recurse-bab","depends_on_id":"recurse-038","type":"parent-child","created_at":"2026-01-13T20:02:05.58054-07:00","created_by":"daemon"}]}
{"id":"recurse-beh","content_hash":"cfb545df304881d754e2dc25066d769d8716b1ca370078dc85309c0c5e5dd7c6","title":"Implement ComputationAdvisor","description":"Implement proactive REPL computation detection.\n\n## Implementation\n- Create internal/rlm/proactive.go\n- Implement ComputationAdvisor with pattern matching\n- Add default patterns: counting, arithmetic, sorting, filtering\n- Add SuggestREPL() for REPL approach suggestions\n- Integrate with orchestrator prompt construction\n\n## Key Types\n```go\ntype ComputationPattern struct {\n    Name    string\n    Regex   *regexp.Regexp\n    Handler func(query string, ctx SessionContext) *REPLSuggestion\n}\n\ntype ComputationAdvisor struct {\n    patterns []ComputationPattern\n}\n\nfunc (a *ComputationAdvisor) SuggestREPL(query, ctx) *REPLSuggestion\n```","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-13T19:56:13.218995-07:00","updated_at":"2026-01-13T19:56:13.218995-07:00","source_repo":".","labels":["implementation","proactive","repl"],"dependencies":[{"issue_id":"recurse-beh","depends_on_id":"recurse-6p2","type":"blocks","created_at":"2026-01-13T20:00:49.810178-07:00","created_by":"daemon"}]}
{"id":"recurse-bo0","content_hash":"de314fd716f069f1376a5318fea69977bb853460c3145aee0212867e804b217c","title":"Add evolution audit log","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-11T06:46:49.902658-07:00","updated_at":"2026-01-11T06:58:46.728385-07:00","closed_at":"2026-01-11T06:58:46.728385-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-bo0","depends_on_id":"recurse-smo","type":"blocks","created_at":"2026-01-11T06:47:49.527317-07:00","created_by":"daemon"},{"issue_id":"recurse-bo0","depends_on_id":"recurse-q7e","type":"blocks","created_at":"2026-01-11T06:47:49.616469-07:00","created_by":"daemon"}]}
{"id":"recurse-bv2","content_hash":"88e4fe5635edad9f28b60ebbd9b831533a56e9eec3e90f689527280aada8ae1b","title":"Tests for Formal Verification","description":"Tests for formal verification integration.\n\n## Test Categories\n\n### Unit Tests\n- Constraint generation from docstrings\n- CPMpy model construction\n- Verification result parsing\n\n### Integration Tests\n- End-to-end verification of code changes\n- Constraint satisfaction on valid changes\n- Constraint violation detection on invalid changes\n\n### Property-Based Tests\n- Invariant: satisfiable constraints produce solutions\n- Invariant: unsatisfiable constraints return conflict","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-13T19:56:15.88854-07:00","updated_at":"2026-01-13T19:56:15.88854-07:00","source_repo":".","labels":["testing","verification"],"dependencies":[{"issue_id":"recurse-bv2","depends_on_id":"recurse-77r","type":"blocks","created_at":"2026-01-13T20:01:06.443914-07:00","created_by":"daemon"}]}
{"id":"recurse-c0d","content_hash":"95cac9becfd38e852cac062f5dec6f0723a6c954ee1a611e3b949c2c8aabfd70","title":"Implement meta-controller (Claude Haiku for orchestration decisions)","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T06:23:54.613584-07:00","updated_at":"2026-01-11T06:39:09.510425-07:00","closed_at":"2026-01-11T06:39:09.510425-07:00","source_repo":"."}
{"id":"recurse-c6v","content_hash":"747a2b577f01353a2239f2558855d1aefb3549e8a0147c05e2ebc36689174ce3","title":"Tests for Adaptive Compute","description":"Tests for adaptive compute allocation.\n\n## Test Categories\n\n### Unit Tests\n- Difficulty estimation for various query types\n- Allocation produces valid configurations\n- Easy queries get shallow/cheap allocation\n- Hard queries get deep/expensive allocation\n\n### Property-Based Tests\n- Invariant: allocation within budget\n- Invariant: difficulty in [0,1]\n\n### Integration Tests\n- End-to-end with real queries\n- Efficiency comparison: static vs adaptive\n\n### Benchmarks\n- Difficulty estimation latency\n- Cost comparison: static vs adaptive (expect 4x improvement)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-13T19:57:05.265294-07:00","updated_at":"2026-01-14T11:05:16.018774-07:00","closed_at":"2026-01-14T11:05:16.018774-07:00","source_repo":".","labels":["compute","testing"],"dependencies":[{"issue_id":"recurse-c6v","depends_on_id":"recurse-ezk","type":"blocks","created_at":"2026-01-13T20:01:09.974382-07:00","created_by":"daemon"}]}
{"id":"recurse-car","content_hash":"c3f37885e90cd4557f23e5c775864c8ea030545d364a99b8ae79fd6adf0abd23","title":"Tests for CircuitBreaker","description":"Tests for circuit breaker implementation.\n\n## Test Categories\n\n### Unit Tests\n- State transitions: Closed -\u003e Open on threshold\n- State transitions: Open -\u003e HalfOpen after timeout\n- State transitions: HalfOpen -\u003e Closed on success\n- State transitions: HalfOpen -\u003e Open on failure\n- Thread safety with concurrent calls\n\n### Property-Based Tests\n- Invariant: failure count never exceeds threshold+1\n- Invariant: open circuit rejects all calls\n- Invariant: half-open allows exactly one test call\n\n### Integration Tests\n- Circuit breaker with real API failures\n- Recovery after transient errors\n- Per-model-tier isolation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-13T19:54:39.074905-07:00","updated_at":"2026-01-14T08:34:43.918034-07:00","closed_at":"2026-01-14T08:34:43.918034-07:00","source_repo":".","labels":["resilience","testing"],"dependencies":[{"issue_id":"recurse-car","depends_on_id":"recurse-2jz","type":"blocks","created_at":"2026-01-13T20:00:28.588816-07:00","created_by":"daemon"}]}
{"id":"recurse-cit","content_hash":"e7482e1640abf4072969874bda1ad9548ffff48471da11474a36d7dd00e5cb04","title":"RLM Enhancement: Architecture Refinements","description":"Architecture improvements for maintainability and extensibility.\n\nBased on rlm-claude-code patterns:\n- Modular orchestrator package\n- REPL plugin system for domain-specific functions\n- Memory backend abstraction\n\nEnables future extensibility and cleaner separation of concerns.","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-13T19:53:09.165308-07:00","updated_at":"2026-01-13T19:53:09.165308-07:00","source_repo":".","labels":["architecture","maintainability","rlm"]}
{"id":"recurse-cmu","content_hash":"a8f1213c8559cab93d4522388e45853faf575aaeb9f3e06e71d11392c9f7ee19","title":"Tests for REPL Plugin System","description":"Tests for REPL plugin system.\n\n## Test Categories\n\n### Unit Tests\n- Plugin registration\n- Function invocation\n- Plugin discovery\n\n### Integration Tests\n- Plugin loading from filesystem\n- Plugin functions in REPL\n- Security constraints enforced","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-13T19:59:35.836397-07:00","updated_at":"2026-01-13T19:59:35.836397-07:00","source_repo":".","labels":["plugins","repl","testing"],"dependencies":[{"issue_id":"recurse-cmu","depends_on_id":"recurse-0gy","type":"blocks","created_at":"2026-01-13T20:01:46.017609-07:00","created_by":"daemon"}]}
{"id":"recurse-co0","content_hash":"e1ff8b9fdc7ff6500758de683f98941c4ad67d79c7ebc6709b7674ef717b674d","title":"Tests for LATS Orchestration","description":"Tests for LATS tool orchestration.\n\n## Test Categories\n\n### Unit Tests\n- UCB1 score computation\n- Plan generation for various queries\n- Tool capability matching\n- MCTS phases execute correctly\n- Backpropagation updates values\n\n### Property-Based Tests\n- Invariant: all plans have valid tool references\n- Invariant: UCB1 balances exploration/exploitation\n- Invariant: dependencies are acyclic\n\n### Integration Tests\n- LATS planning with real tool execution\n- Fallback handling on tool failures\n- End-to-end task completion\n\n### Benchmarks\n- Planning overhead\n- Comparison: reactive vs LATS (expect 2x improvement)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-13T19:56:11.846095-07:00","updated_at":"2026-01-14T09:51:32.791066-07:00","closed_at":"2026-01-14T09:51:32.791066-07:00","source_repo":".","labels":["lats","testing"],"dependencies":[{"issue_id":"recurse-co0","depends_on_id":"recurse-0pm","type":"blocks","created_at":"2026-01-13T20:00:49.147035-07:00","created_by":"daemon"}]}
{"id":"recurse-cvr","content_hash":"73df8b547a72e877aa620b9a741909c1a8c56beb58210925d1be1e4f7c259344","title":"Tests for Memory Backend","description":"Tests for memory backend abstraction.\n\n## Test Categories\n\n### Unit Tests\n- SQLiteBackend CRUD operations\n- InMemoryBackend CRUD operations\n- Interface compliance\n\n### Integration Tests\n- Store with SQLiteBackend\n- Store with InMemoryBackend\n- Backend switching\n\n### Property-Based Tests\n- Invariant: same operations produce same results on both backends","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T19:59:37.876466-07:00","updated_at":"2026-01-14T12:06:04.582348-07:00","closed_at":"2026-01-14T12:06:04.582348-07:00","source_repo":".","labels":["memory","testing"],"dependencies":[{"issue_id":"recurse-cvr","depends_on_id":"recurse-b5h","type":"blocks","created_at":"2026-01-13T20:01:47.497992-07:00","created_by":"daemon"}]}
{"id":"recurse-dbi","content_hash":"be7ecf4ca9ea720b180acc4c129bbba598b0f23421e323ad3da0b8b4f4b60348","title":"Integrate RLM controller with hypergraph memory","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T06:59:39.589522-07:00","updated_at":"2026-01-11T07:02:23.671377-07:00","closed_at":"2026-01-11T07:02:23.671377-07:00","source_repo":"."}
{"id":"recurse-dcn","content_hash":"b411135feb407a21931e0a6b17328234b8eafceee874b210b4c2ccbcadf7bc55","title":"[SPEC] Learned Model Routing Design","description":"Design specification for learned model routing.\n\n## Research Basis\nRouteLLM (ICLR 2025) achieves 85% cost reduction while maintaining 95% of GPT-4 performance.\n\n## Requirements\n- Define LearnedRouter interface\n- Specify model profiles with strengths\n- Design cascading with confidence threshold\n- Define integration with ContinuousLearner\n- Specify fallback behavior\n\n## Deliverables\n- Spec document: docs/spec/learned-routing.md\n- Interface: internal/rlm/routing/learned.go\n\n## Acceptance Criteria\n- [ ] Spec covers model profiles\n- [ ] Spec covers cascading strategy\n- [ ] Spec covers learned adjustments\n- [ ] Spec covers cost sensitivity\n- [ ] Spec defines expected cost reduction","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T19:58:39.260976-07:00","updated_at":"2026-01-13T21:01:24.240562-07:00","closed_at":"2026-01-13T21:01:24.240562-07:00","source_repo":".","labels":["learning","routing","spec"],"dependencies":[{"issue_id":"recurse-dcn","depends_on_id":"recurse-kes","type":"parent-child","created_at":"2026-01-13T20:02:26.503541-07:00","created_by":"daemon"}]}
{"id":"recurse-dex","content_hash":"ec2ad67a9edbd6bc86c92bc3b5a3a55832822821120091ad5b91bc94e2ecdedc","title":"Epic: RLM Performance Optimization","description":"Optimize RLM mode execution speed and reduce latency. Current RLM execution is 10-20x slower than Direct mode due to multiple LLM round-trips and REPL overhead.\n\n**Current Performance** (from benchmarks):\n- Needle 8K: Direct 21s vs RLM 3m37s\n- RLM uses 4-5 iterations typically\n\n**Optimization Targets**:\n1. Reduce average iterations from 4-5 to 2-3\n2. Reduce per-iteration latency\n3. Add early termination for simple tasks\n4. Consider parallel exploration strategies\n\n**Success Criteria**:\n- RLM execution time reduced by 50%+ for common tasks\n- Maintain accuracy (no regression)\n- Better perceived responsiveness through streaming","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-01-12T08:04:55.68361-07:00","updated_at":"2026-01-12T08:50:55.159464-07:00","closed_at":"2026-01-12T08:50:55.159464-07:00","source_repo":"."}
{"id":"recurse-dex.1","content_hash":"e82246aa3ca453352bb9b83c11d2585e2a813dd6318512d7e2070a5c8490a6fd","title":"Profile RLM execution to identify latency bottlenecks","description":"Add instrumentation to measure where time is spent in RLM execution.\n\n**Metrics to Capture**:\n- Time per iteration breakdown:\n  - LLM call latency\n  - REPL execution time\n  - Context preparation overhead\n  - Response parsing time\n- Total iterations per task type\n- Token usage per iteration\n\n**Implementation**:\n1. Add timing instrumentation to wrapper.go ExecuteRLM loop\n2. Log structured metrics (slog with attributes)\n3. Create summary report after execution\n\n**Deliverable**: Profile data from benchmark suite showing bottleneck distribution","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-12T08:05:04.632337-07:00","updated_at":"2026-01-12T08:32:38.050805-07:00","closed_at":"2026-01-12T08:32:38.050805-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-dex.1","depends_on_id":"recurse-dex","type":"parent-child","created_at":"2026-01-12T08:05:04.633203-07:00","created_by":"daemon"}]}
{"id":"recurse-dex.2","content_hash":"114eb6c63b1b2b455d675a8aeff53b489777916e586eac14d8c16808ca82464a","title":"Optimize iteration strategy with smarter prompting","description":"Reduce iteration count by improving the RLM system prompt to encourage more efficient exploration.\n\n**Current Issue**: LLM often takes exploratory steps that could be combined.\n\n**Optimizations**:\n1. Better system prompt that encourages single-step solutions for simple tasks\n2. Provide example patterns for common operations (count, sum, find)\n3. Encourage FINAL() call when answer is clear, not additional verification\n4. Include task-type hint from classifier to guide strategy\n\n**Target**: Reduce median iterations from 4 to 2 for counting/aggregation tasks","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-12T08:05:15.124484-07:00","updated_at":"2026-01-12T08:37:58.804103-07:00","closed_at":"2026-01-12T08:37:58.804103-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-dex.2","depends_on_id":"recurse-dex","type":"parent-child","created_at":"2026-01-12T08:05:15.125496-07:00","created_by":"daemon"},{"issue_id":"recurse-dex.2","depends_on_id":"recurse-dex.1","type":"blocks","created_at":"2026-01-12T08:05:15.126867-07:00","created_by":"daemon"}]}
{"id":"recurse-dex.3","content_hash":"a91a78c6659ea0aa2ef0020aa02bd9c4107d2a5fa1c52ad18debfe33063ef369","title":"Implement early termination for high-confidence answers","description":"Add logic to terminate RLM loop early when the answer is clearly determined.\n\n**Scenarios for Early Termination**:\n1. FINAL() called with high-confidence answer\n2. Same answer produced in consecutive iterations\n3. Simple task completed in first iteration (e.g., single regex count)\n\n**Implementation**:\n```go\ntype TerminationCheck struct {\n    ShouldTerminate bool\n    Reason          string\n    Confidence      float64\n}\n\nfunc (w *Wrapper) checkEarlyTermination(iteration int, result *IterationResult) TerminationCheck {\n    // Check for FINAL() call\n    // Check for answer stability\n    // Check for simple task completion\n}\n```\n\n**Guard**: Must not terminate prematurely for multi-step tasks","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-12T08:05:23.967992-07:00","updated_at":"2026-01-12T08:43:01.443338-07:00","closed_at":"2026-01-12T08:43:01.443338-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-dex.3","depends_on_id":"recurse-dex","type":"parent-child","created_at":"2026-01-12T08:05:23.968868-07:00","created_by":"daemon"},{"issue_id":"recurse-dex.3","depends_on_id":"recurse-dex.1","type":"blocks","created_at":"2026-01-12T08:05:23.969931-07:00","created_by":"daemon"}]}
{"id":"recurse-dex.4","content_hash":"58241fdfbeb0fe246f625bc710c9d36dd27764007d5d3d9fda65a009cc961439","title":"Add streaming output for RLM iterations","description":"Stream RLM progress to improve perceived responsiveness.\n\n**Current UX**: User waits with no feedback during 2-4 minute RLM execution.\n\n**Improvement**: Stream iteration progress and intermediate results.\n\n**Output Format**:\n```\n[RLM] Iteration 1/10: Searching context for pattern...\n[RLM] Found 3 matches, analyzing...\n[RLM] Iteration 2/10: Computing sum of values...\n[RLM] Answer: 42\n```\n\n**Implementation**:\n1. Add progress callback to RLMConfig\n2. Emit events at iteration start/end\n3. Optionally stream REPL output\n4. TUI integration for progress display","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-12T08:05:33.334159-07:00","updated_at":"2026-01-12T08:50:49.856749-07:00","closed_at":"2026-01-12T08:50:49.856749-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-dex.4","depends_on_id":"recurse-dex","type":"parent-child","created_at":"2026-01-12T08:05:33.335119-07:00","created_by":"daemon"}]}
{"id":"recurse-df9","content_hash":"c1dc54636911d27fd6a621d4210f80c3c2d288ded4a6ad8474160689cf6a2c83","title":"Add RLM trace view TUI panel","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-11T06:23:54.956973-07:00","updated_at":"2026-01-11T06:45:31.699437-07:00","closed_at":"2026-01-11T06:45:31.699437-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-df9","depends_on_id":"recurse-3yb","type":"blocks","created_at":"2026-01-11T06:29:26.458412-07:00","created_by":"daemon"}]}
{"id":"recurse-dl7","content_hash":"bcf62f52b0a8125186ae3d988f72f0e627ffbc3fcaaf9dc1548acb4d55d19efb","title":"Refactor to Modular Orchestrator","description":"Refactor orchestration code into modular package.\n\n## Implementation\n- Create internal/rlm/orchestrator/ directory\n- Move base loop to core.go\n- Move intelligent decisions to intelligent.go\n- Move async execution to async.go\n- Move checkpointing to checkpointing.go\n- Update imports across codebase\n\n## Target Structure\n```\ninternal/rlm/orchestrator/\n├── core.go           # Base orchestration loop\n├── intelligent.go    # Claude-powered decisions\n├── async.go          # Async execution engine\n├── checkpointing.go  # Session persistence\n└── steering.go       # User interaction\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T19:59:32.894089-07:00","updated_at":"2026-01-14T12:24:37.921658-07:00","closed_at":"2026-01-14T12:24:37.921658-07:00","source_repo":".","labels":["architecture","implementation","refactor"],"dependencies":[{"issue_id":"recurse-dl7","depends_on_id":"recurse-o3l","type":"blocks","created_at":"2026-01-13T20:01:34.234509-07:00","created_by":"daemon"}]}
{"id":"recurse-dts","content_hash":"85e6c3a18b60e52f47ce4ffce99f80e91bd6e5484635504ab601b6793c293ad6","title":"Memory nodes never reach longterm tier - access_count stays 0","description":"Memory nodes are created but never promoted to the longterm tier because:\n\n1. **access_count is always 0** - Nodes are created with access_count=0 and it's rarely incremented\n2. **IncrementAccess only called in executeMemoryQuery** - Most code paths don't increment access\n3. **Promotion thresholds** require access_count \u003e= 5 for session→longterm promotion\n\n**Evidence from database:**\n```sql\nSELECT access_count, tier FROM nodes;\n-- All nodes show: access_count=0, tier=session\n```\n\n**Current tier distribution:**\n- session: 13 nodes\n- task: 1 node\n- longterm: 0 nodes\n\n**Fix required:**\n1. Call `store.IncrementAccess()` when nodes are used in responses\n2. Consider auto-promoting facts that are referenced during task completion\n3. Possibly reduce SessionToLongtermThreshold from 5 to 2-3 for more natural promotion","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-13T17:36:03.511265-07:00","updated_at":"2026-01-13T18:21:45.902259-07:00","closed_at":"2026-01-13T18:21:45.902259-07:00","source_repo":".","labels":["evolution","memory"]}
{"id":"recurse-dwo","content_hash":"881b9f2e6d73aa7c7a87746e5780649f6ac90a0a847217e7ec842f2b8510996c","title":"Add evolution lifecycle hooks (task/session boundaries)","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T06:59:40.253299-07:00","updated_at":"2026-01-11T07:07:27.500735-07:00","closed_at":"2026-01-11T07:07:27.500735-07:00","source_repo":"."}
{"id":"recurse-e8e","content_hash":"dbcc321e9644a4bac12ace6f7f8cc2179c681fba0d6e540196a575f443a8c355","title":"Epic: Task-Type Detection for Smart Mode Selection","description":"Implement intelligent task classification to select RLM vs Direct mode based on task semantics, not just context size. Currently mode selection uses a simple 4K token threshold. This epic adds heuristics to detect computational tasks (counting, aggregation, pattern matching) that benefit from RLM even at smaller context sizes, and retrieval tasks that should use Direct even at larger sizes.\n\n**Problem**: Current threshold-based selection misses cases where:\n- Small context needs computation (should use RLM)\n- Large context is simple retrieval (should use Direct)\n\n**Success Criteria**:\n- Task classifier with \u003e90% accuracy on benchmark suite\n- Mode selection incorporates task type alongside context size\n- Benchmark shows improved token efficiency across task types","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-12T08:04:05.213912-07:00","updated_at":"2026-01-12T08:26:05.670512-07:00","closed_at":"2026-01-12T08:26:05.670512-07:00","source_repo":"."}
{"id":"recurse-e8e.1","content_hash":"9ed3abf91dba9ee0d2ce5e1d6160609ae1d8c8aa00e93465521c8ea88440c284","title":"Define task taxonomy and classification signals","description":"Research and define the taxonomy of task types and the signals that distinguish them.\n\n**Task Types**:\n1. Computational: counting, summing, aggregation, pattern matching\n2. Retrieval: needle-in-haystack, fact lookup, simple Q\u0026A\n3. Analytical: multi-hop reasoning, comparison, synthesis\n4. Transformational: rewriting, translation, formatting\n\n**Classification Signals to Analyze**:\n- Query keywords: 'count', 'how many', 'sum', 'total', 'find', 'what is'\n- Query structure: question type, verb patterns\n- Context characteristics: structured vs unstructured, data density\n\n**Deliverable**: Document in docs/design/task-classification.md","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-12T08:04:13.535427-07:00","updated_at":"2026-01-12T08:09:51.938638-07:00","closed_at":"2026-01-12T08:09:51.938638-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-e8e.1","depends_on_id":"recurse-e8e","type":"parent-child","created_at":"2026-01-12T08:04:13.536361-07:00","created_by":"daemon"}]}
{"id":"recurse-e8e.2","content_hash":"e2ac5ec59064bd38fe559102747003190f1800527eb0dfb7851a46bc64495db9","title":"Implement TaskClassifier with keyword and pattern matching","description":"Implement the core TaskClassifier component that analyzes queries to determine task type.\n\n**Location**: internal/rlm/classifier.go\n\n**Interface**:\n```go\ntype TaskType string\nconst (\n    TaskTypeComputational TaskType = \"computational\"\n    TaskTypeRetrieval     TaskType = \"retrieval\"\n    TaskTypeAnalytical    TaskType = \"analytical\"\n    TaskTypeUnknown       TaskType = \"unknown\"\n)\n\ntype Classification struct {\n    Type       TaskType\n    Confidence float64  // 0.0-1.0\n    Signals    []string // What triggered this classification\n}\n\ntype TaskClassifier interface {\n    Classify(query string, contexts []ContextSource) Classification\n}\n```\n\n**Implementation**:\n1. Keyword matching (count, sum, find, etc.)\n2. Regex patterns for question types\n3. Context analysis (numeric density, structure)\n4. Confidence scoring based on signal strength","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-12T08:04:22.659583-07:00","updated_at":"2026-01-12T08:13:33.078192-07:00","closed_at":"2026-01-12T08:13:33.078192-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-e8e.2","depends_on_id":"recurse-e8e","type":"parent-child","created_at":"2026-01-12T08:04:22.661003-07:00","created_by":"daemon"},{"issue_id":"recurse-e8e.2","depends_on_id":"recurse-e8e.1","type":"blocks","created_at":"2026-01-12T08:04:22.662124-07:00","created_by":"daemon"}]}
{"id":"recurse-e8e.3","content_hash":"95d6045261cc5345ac6d3380fa2bdde3d5781ca889fac63936c935f90c940abb","title":"Integrate TaskClassifier into mode selection logic","description":"Modify wrapper.go:shouldUseRLMMode() to incorporate task classification alongside context size.\n\n**Current Logic** (wrapper.go:122-138):\n- Uses only context size threshold (4K tokens)\n\n**New Logic**:\n```go\nfunc (w *Wrapper) shouldUseRLMMode(query string, totalTokens int, contexts []ContextSource) bool {\n    classification := w.classifier.Classify(query, contexts)\n    \n    // Computational tasks: prefer RLM even for smaller contexts\n    if classification.Type == TaskTypeComputational \u0026\u0026 classification.Confidence \u003e 0.8 {\n        return totalTokens \u003e= 1000 \u0026\u0026 w.replMgr != nil\n    }\n    \n    // Retrieval tasks: prefer Direct even for larger contexts  \n    if classification.Type == TaskTypeRetrieval \u0026\u0026 classification.Confidence \u003e 0.8 {\n        return false\n    }\n    \n    // Default: use existing size threshold\n    return totalTokens \u003e= w.minContextTokensForRLM \u0026\u0026 w.replMgr != nil\n}\n```\n\n**Config additions**:\n- MinTokensForComputationalRLM: 1000 (lower threshold for computational)\n- ClassificationConfidenceThreshold: 0.8","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-12T08:04:33.463282-07:00","updated_at":"2026-01-12T08:18:13.308307-07:00","closed_at":"2026-01-12T08:18:13.308307-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-e8e.3","depends_on_id":"recurse-e8e","type":"parent-child","created_at":"2026-01-12T08:04:33.464427-07:00","created_by":"daemon"},{"issue_id":"recurse-e8e.3","depends_on_id":"recurse-e8e.2","type":"blocks","created_at":"2026-01-12T08:04:33.46567-07:00","created_by":"daemon"}]}
{"id":"recurse-e8e.4","content_hash":"b5661d93af4483d9b6a7df6815a793c5561bee57a982d281fd46711a1e74752a","title":"Add classifier accuracy tests using benchmark suite","description":"Create test suite to validate TaskClassifier accuracy against known task types.\n\n**Test Cases**:\n- Counting tasks from benchmark generators → should classify as computational\n- Needle tasks → should classify as retrieval\n- Aggregation tasks → should classify as computational\n- Pairing tasks → should classify as analytical\n\n**Location**: internal/rlm/classifier_test.go\n\n**Success Criteria**:\n- \u003e90% accuracy on benchmark task corpus\n- Confidence scores correlate with actual RLM vs Direct performance\n- No false positives that would hurt performance (e.g., classifying retrieval as computational)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-12T08:04:45.045906-07:00","updated_at":"2026-01-12T08:25:23.225045-07:00","closed_at":"2026-01-12T08:25:23.225045-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-e8e.4","depends_on_id":"recurse-e8e","type":"parent-child","created_at":"2026-01-12T08:04:45.04689-07:00","created_by":"daemon"},{"issue_id":"recurse-e8e.4","depends_on_id":"recurse-e8e.2","type":"blocks","created_at":"2026-01-12T08:04:45.047771-07:00","created_by":"daemon"}]}
{"id":"recurse-eim","content_hash":"bffad88ed9bccbc362e65ad6fe038ad442cb2e18000fbbd2d1f4408a5d609807","title":"[SPEC] Embedding Integration Design","description":"Design specification for embedding-based semantic memory search.\n\n## Research Basis\n- A-MEM (NeurIPS 2025): Agentic memory with semantic retrieval\n- Zep: Temporal knowledge graphs with embeddings\n\n## Requirements\n- Define EmbeddingClient interface for provider abstraction\n- Specify VoyageClient implementation (Voyage-3, VoyageCode-3)\n- Design hybrid search combining FTS5 + vector similarity\n- Define embedding storage schema (SQLite vec extension)\n- Specify batch embedding strategy for efficiency\n\n## Deliverables\n- Spec document: docs/spec/embeddings.md\n- Interface: internal/memory/hypergraph/embeddings.go\n- Schema additions for node_embeddings table\n\n## Acceptance Criteria\n- [ ] Spec covers embedding model selection (Voyage-3 vs VoyageCode-3)\n- [ ] Spec covers hybrid search with reciprocal rank fusion\n- [ ] Spec covers batch embedding for bulk operations\n- [ ] Schema supports 1024-dimensional vectors","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-13T19:54:33.463384-07:00","updated_at":"2026-01-13T20:14:47.114367-07:00","closed_at":"2026-01-13T20:14:47.114367-07:00","source_repo":".","labels":["embeddings","memory","spec"],"dependencies":[{"issue_id":"recurse-eim","depends_on_id":"recurse-038","type":"parent-child","created_at":"2026-01-13T20:02:04.857316-07:00","created_by":"daemon"}]}
{"id":"recurse-ezk","content_hash":"98d5f74a7360a880cc9fc0992a329e850f76d97ee59a54c921695f18d22dd838","title":"Implement AllocateCompute","description":"Implement adaptive compute allocation based on query difficulty.\n\n## Implementation\n- Create internal/rlm/compute.go\n- Implement estimateDifficulty() with signal extraction\n- Implement AllocateCompute() with allocation strategy\n- Add difficulty buckets: easy, medium, hard\n- Integrate with orchestrator for dynamic depth\n\n## Key Types\n```go\ntype ComputeAllocation struct {\n    DepthBudget   int\n    ModelTier     string\n    ParallelCalls int\n    TimeoutMS     int\n    EstimatedCost float64\n}\n\nfunc AllocateCompute(query, context, budget) ComputeAllocation\nfunc estimateDifficulty(query, context) float64\n```\n\n## Expected Impact\n4x efficiency gains through adaptive allocation.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-13T19:57:04.570552-07:00","updated_at":"2026-01-14T11:01:59.87671-07:00","closed_at":"2026-01-14T11:01:59.87671-07:00","source_repo":".","labels":["compute","implementation","performance"],"dependencies":[{"issue_id":"recurse-ezk","depends_on_id":"recurse-jf5","type":"blocks","created_at":"2026-01-13T20:01:09.2675-07:00","created_by":"daemon"}]}
{"id":"recurse-f92","content_hash":"73381dc2a1955bf18734ee8efa9ac2df04ac654bddf584b564120c1cb39e1ef8","title":"Tests for Embedding Integration","description":"Tests for embedding client and hybrid search.\n\n## Test Categories\n\n### Unit Tests\n- VoyageClient embeds text correctly\n- VoyageClient handles batch requests\n- VectorSearch returns similar nodes\n- HybridSearch combines results properly\n- Reciprocal rank fusion weighting\n\n### Integration Tests\n- End-to-end embedding and retrieval\n- CreateNode with embedding computation\n- Search quality comparison: keyword vs hybrid\n\n### Property-Based Tests\n- Invariant: similar texts have similar embeddings\n- Invariant: hybrid search returns superset of keyword results\n\n### Benchmarks\n- Embedding latency for various batch sizes\n- Search latency: FTS5 vs vector vs hybrid","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-13T19:54:35.317321-07:00","updated_at":"2026-01-14T08:03:54.282937-07:00","closed_at":"2026-01-14T08:03:54.282937-07:00","source_repo":".","labels":["embeddings","testing"],"dependencies":[{"issue_id":"recurse-f92","depends_on_id":"recurse-6qp","type":"blocks","created_at":"2026-01-13T20:00:25.890213-07:00","created_by":"daemon"}]}
{"id":"recurse-fro","content_hash":"86a544e0c27d7769b0bf81beb2091badcb3b21b0f90cf2a803a01707b4481600","title":"Integrate RLM trace view into TUI","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-11T07:13:27.071733-07:00","updated_at":"2026-01-11T07:20:33.35451-07:00","closed_at":"2026-01-11T07:20:33.35451-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-fro","depends_on_id":"recurse-zhb","type":"blocks","created_at":"2026-01-11T07:13:43.266322-07:00","created_by":"daemon"}]}
{"id":"recurse-frw","content_hash":"d2dc41ab2d2b7747920a8986b2ccb8ddb4087629cad8ab8750878f9f7868e1f6","title":"Add integration test for end-to-end RLM task execution","description":"Create an integration test that validates the complete RLM flow:\n\n1. Submit a task via `recurse rlm \"question\"`\n2. Verify meta-controller makes orchestration decision\n3. Verify response is actually generated (not just echoed)\n4. Verify trace events are recorded\n5. Verify memory nodes are created\n6. Verify task completion triggers consolidation\n\n**Current state:**\n- Unit tests pass but don't catch the executeDirect placeholder issue\n- No end-to-end validation of user experience\n\n**Suggested test scenarios:**\n- Simple question (should use DIRECT)\n- Large context analysis (should use DECOMPOSE)\n- Multi-file code review (should use SUBCALL)\n- Follow-up question (should use MEMORY_QUERY)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-13T17:36:05.508997-07:00","updated_at":"2026-01-13T18:33:52.14803-07:00","closed_at":"2026-01-13T18:33:52.14803-07:00","source_repo":".","labels":["rlm","testing"],"dependencies":[{"issue_id":"recurse-frw","depends_on_id":"recurse-9s8","type":"blocks","created_at":"2026-01-13T17:38:47.605928-07:00","created_by":"daemon"},{"issue_id":"recurse-frw","depends_on_id":"recurse-1x9","type":"blocks","created_at":"2026-01-13T17:38:48.260942-07:00","created_by":"daemon"}]}
{"id":"recurse-g1q","content_hash":"7aa252ccf5c5f1fd3eb8cd836436100013023155631f3b705f6b8f75798f2db9","title":"Tests for Execution Guarantees","description":"Tests for execution guarantees implementation.\n\n## Test Categories\n\n### Unit Tests\n- CanProceed returns false at limit\n- OnBudgetExhausted produces valid plan\n- Cost/time/call tracking accurate\n- Limits enforced independently\n\n### Property-Based Tests\n- Invariant: CanProceed false after limit reached\n- Invariant: costUsed \u003c= maxCostUSD\n\n### Integration Tests\n- End-to-end with Controller\n- Graceful degradation produces partial results","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-13T19:57:50.100125-07:00","updated_at":"2026-01-14T11:18:16.790797-07:00","closed_at":"2026-01-14T11:18:16.790797-07:00","source_repo":".","labels":["reliability","testing"],"dependencies":[{"issue_id":"recurse-g1q","depends_on_id":"recurse-45y","type":"blocks","created_at":"2026-01-13T20:01:11.36245-07:00","created_by":"daemon"}]}
{"id":"recurse-i0i","content_hash":"a9102f8bed158f8084002afb2d63c938274d2b91835f5f8f47cb04c52f6fbc25","title":"Implement OpenRouter RLM integration with intelligent model routing","description":"","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-11T15:17:15.121675-07:00","updated_at":"2026-01-11T15:17:21.403869-07:00","closed_at":"2026-01-11T15:17:21.403869-07:00","source_repo":"."}
{"id":"recurse-jdf","content_hash":"1f40f25a83686b1c85f688a4535bd00ea5b6ef4144bbfd2bf21b64b1a1676fab","title":"Implement hyperedge types and membership","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T12:44:42.506603-07:00","updated_at":"2026-01-10T12:52:35.502687-07:00","closed_at":"2026-01-10T12:52:35.502687-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-jdf","depends_on_id":"recurse-0yb","type":"blocks","created_at":"2026-01-10T12:45:35.064564-07:00","created_by":"daemon"}]}
{"id":"recurse-jf5","content_hash":"e962bb07574adb3ccfea077c470e64f0b6bac41842afb0be4e06062af7aec65e","title":"[SPEC] Adaptive Depth Allocation Design","description":"Design specification for compute-optimal depth allocation.\n\n## Research Basis\nInference Scaling Laws (ICLR 2025) demonstrated 4x efficiency gains through adaptive per-prompt compute allocation.\n\n## Requirements\n- Define difficulty estimation heuristics\n- Specify ComputeAllocation structure\n- Design allocation strategy based on difficulty\n- Specify model tier selection by difficulty\n- Define parallel call limits by difficulty\n\n## Deliverables\n- Spec document: docs/spec/adaptive-compute.md\n- Interface: internal/rlm/compute.go\n\n## Acceptance Criteria\n- [ ] Spec covers difficulty estimation\n- [ ] Spec covers allocation buckets (easy/medium/hard)\n- [ ] Spec covers model tier selection\n- [ ] Spec covers parallel call limits\n- [ ] Spec defines expected efficiency gains","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-13T19:57:03.850145-07:00","updated_at":"2026-01-13T20:27:40.515552-07:00","closed_at":"2026-01-13T20:27:40.515552-07:00","source_repo":".","labels":["compute","performance","spec"],"dependencies":[{"issue_id":"recurse-jf5","depends_on_id":"recurse-qdb","type":"parent-child","created_at":"2026-01-13T20:02:10.741511-07:00","created_by":"daemon"}]}
{"id":"recurse-jow","content_hash":"d386b1bf16f8dd37696be79c1641772d74d5b57b8f718e81089080c1a8c152fa","title":"Implement ContextCompressor","description":"Implement two-stage context compression.\n\n## Implementation\n- Create internal/rlm/compress/compressor.go\n- Implement extractive compression with sentence scoring\n- Implement abstractive compression via LLM\n- Add Compress() with threshold-based stage selection\n- Add compression metrics tracking\n\n## Key Types\n```go\ntype ContextCompressor struct {\n    extractiveThreshold int\n    abstractiveThreshold int\n    embedder EmbeddingClient\n}\n\nfunc (c *ContextCompressor) Compress(ctx, content, targetTokens) (string, error)\nfunc (c *ContextCompressor) extractive(content, target) string\nfunc (c *ContextCompressor) abstractive(ctx, content, target) string\n```\n\n## Expected Impact\n3-4x compression with 2x latency reduction.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-13T19:57:02.340645-07:00","updated_at":"2026-01-14T09:58:00.66793-07:00","closed_at":"2026-01-14T09:58:00.66793-07:00","source_repo":".","labels":["compression","implementation","performance"],"dependencies":[{"issue_id":"recurse-jow","depends_on_id":"recurse-8z6","type":"blocks","created_at":"2026-01-13T20:01:07.151901-07:00","created_by":"daemon"},{"issue_id":"recurse-jow","depends_on_id":"recurse-qm2","type":"blocks","created_at":"2026-01-13T20:01:07.857783-07:00","created_by":"daemon"}]}
{"id":"recurse-k3i","content_hash":"e58f07d715b5fce2f541b288cb6d4a5960e6a9b921d41c105385c66141e22cdb","title":"Implement AsyncRLMExecutor","description":"Implement async execution engine for parallel recursive calls.\n\n## Implementation\n- Create internal/rlm/async/executor.go with AsyncRLMExecutor\n- Implement ExecuteParallel for independent operations\n- Implement SpeculativeExecute for racing alternatives\n- Add semaphore-based concurrency control\n- Integrate with budget tracker for cost-aware parallelism\n\n## Expected Impact\n3-5x latency reduction for multi-call queries.\n\n## Key Functions\n```go\ntype AsyncRLMExecutor struct {\n    maxConcurrency int\n    semaphore      chan struct{}\n}\n\nfunc (e *AsyncRLMExecutor) ExecuteParallel(ctx, ops) ([]Result, error)\nfunc (e *AsyncRLMExecutor) SpeculativeExecute(ctx, primary, alts) (Result, error)\n```","status":"closed","priority":0,"issue_type":"feature","created_at":"2026-01-13T19:54:32.224318-07:00","updated_at":"2026-01-14T08:15:06.867629-07:00","closed_at":"2026-01-14T08:15:06.867629-07:00","source_repo":".","labels":["async","critical","implementation"],"dependencies":[{"issue_id":"recurse-k3i","depends_on_id":"recurse-8yz","type":"blocks","created_at":"2026-01-13T20:00:22.47712-07:00","created_by":"daemon"}]}
{"id":"recurse-kes","content_hash":"843a0ab64856535a51f67e41c2af43c575d18112d7b6f33d04dde7837536b955","title":"RLM Enhancement: Learning \u0026 Adaptation","description":"Learning and adaptation for self-improvement over time.\n\nResearch basis:\n- Agent Lightning (Microsoft 2025): RL-based training without code changes\n- RouteLLM (ICLR 2025): 85% cost reduction via learned routing\n- ToTRL (2025): Learning from feedback improves reasoning\n\nIncludes:\n- Continuous learning from outcomes\n- Learned model routing\n- User correction learning","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-01-13T19:53:08.558108-07:00","updated_at":"2026-01-14T12:00:11.808688-07:00","closed_at":"2026-01-14T12:00:11.808688-07:00","source_repo":".","labels":["adaptation","learning","rlm"]}
{"id":"recurse-kii","content_hash":"3b94c075fa8b7b2ecfd9d78a2b90e8da70ff5c5e57ce969746b7be6c67a82781","title":"Tests for Weighted Synthesis","description":"Tests for confidence-weighted synthesis.\n\n## Test Categories\n\n### Unit Tests\n- Weight normalization sums to 1\n- High-confidence results weighted more\n- Low-confidence results can be filtered\n- Weighted prompt construction correct\n\n### Integration Tests\n- End-to-end with Controller\n- Quality comparison: equal vs weighted\n\n### Property-Based Tests\n- Invariant: weights sum to 1.0\n- Invariant: all results represented in synthesis","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-13T19:57:52.045886-07:00","updated_at":"2026-01-14T11:30:19.840514-07:00","closed_at":"2026-01-14T11:30:19.840514-07:00","source_repo":".","labels":["synthesis","testing"],"dependencies":[{"issue_id":"recurse-kii","depends_on_id":"recurse-8yp","type":"blocks","created_at":"2026-01-13T20:01:27.456502-07:00","created_by":"daemon"}]}
{"id":"recurse-kum","content_hash":"32561fee49c9cc0d76a586e18b1dddd35952421199ed0d79ee1b4dacd46615ce","title":"[SPEC] Execution Guarantees Design","description":"Design specification for hard execution boundaries.\n\n## Research Basis\nRLM paper acknowledges \"lack of strong guarantees about controlling total API cost or total runtime.\"\n\n## Requirements\n- Define ExecutionGuarantees structure with limits\n- Specify hard vs soft limit enforcement\n- Design CanProceed() check with cost estimation\n- Specify graceful degradation on budget exhaustion\n- Define DegradationPlan for partial results\n\n## Deliverables\n- Spec document: docs/spec/execution-guarantees.md\n- Interface: internal/rlm/guarantees.go\n\n## Acceptance Criteria\n- [ ] Spec covers hard budget/time/call limits\n- [ ] Spec covers CanProceed() semantics\n- [ ] Spec covers graceful degradation\n- [ ] Spec defines partial result synthesis","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-13T19:57:48.641699-07:00","updated_at":"2026-01-13T20:27:39.75498-07:00","closed_at":"2026-01-13T20:27:39.75498-07:00","source_repo":".","labels":["guarantees","reliability","spec"],"dependencies":[{"issue_id":"recurse-kum","depends_on_id":"recurse-10h","type":"parent-child","created_at":"2026-01-13T20:02:24.245403-07:00","created_by":"daemon"}]}
{"id":"recurse-l4k","content_hash":"7c7ee29ae4d0671f8689246dd09a2717167878bdb93b7bc9673fcbde8ee9f1f8","title":"Epic: Phase 1 - Foundation (MVP)","description":"","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-10T12:13:53.281801-07:00","updated_at":"2026-01-10T12:44:01.189647-07:00","closed_at":"2026-01-10T12:44:01.189647-07:00","source_repo":"."}
{"id":"recurse-mld","content_hash":"e5836093bb43ecaef373d9fa5ab167c90d110f38e268efe38a4a96b1640d06d6","title":"Implement CacheAwareClient","description":"Implement prompt caching optimization for Claude API calls.\n\n## Implementation\n- Create internal/rlm/cache/client.go\n- Implement CacheAwareClient wrapper\n- Add PrepareCacheablePrompt for optimal structuring\n- Implement cache prefix registry\n- Add cache metrics tracking\n\n## Key Functions\n```go\ntype CacheAwareClient struct {\n    inner       anthropic.Client\n    prefixRegistry map[string]string\n    metrics     *CacheMetrics\n}\n\nfunc (c *CacheAwareClient) PrepareCacheablePrompt(\n    sharedContext string,\n    querySpecific string,\n) anthropic.MessageParams\n\nfunc (c *CacheAwareClient) Complete(ctx, params) (Response, error)\n```\n\n## Expected Impact\n- 90% cost reduction for cached contexts\n- 85% latency reduction for cache hits","status":"closed","priority":0,"issue_type":"feature","created_at":"2026-01-13T19:54:36.546411-07:00","updated_at":"2026-01-14T08:26:05.900071-07:00","closed_at":"2026-01-14T08:26:05.900071-07:00","source_repo":".","labels":["caching","cost","implementation"],"dependencies":[{"issue_id":"recurse-mld","depends_on_id":"recurse-bab","type":"blocks","created_at":"2026-01-13T20:00:26.530669-07:00","created_by":"daemon"}]}
{"id":"recurse-nq7","content_hash":"1ee9a83ed83bb33868874fdf3d0f632f6969dfe9a58b1a86baea7dfdef3e4f2c","title":"Create unified RLM service with all subsystems","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T06:59:40.549773-07:00","updated_at":"2026-01-11T07:09:22.1878-07:00","closed_at":"2026-01-11T07:09:22.1878-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-nq7","depends_on_id":"recurse-dbi","type":"blocks","created_at":"2026-01-11T06:59:46.453532-07:00","created_by":"daemon"},{"issue_id":"recurse-nq7","depends_on_id":"recurse-wxf","type":"blocks","created_at":"2026-01-11T06:59:46.540117-07:00","created_by":"daemon"},{"issue_id":"recurse-nq7","depends_on_id":"recurse-dwo","type":"blocks","created_at":"2026-01-11T06:59:46.630759-07:00","created_by":"daemon"}]}
{"id":"recurse-nyu","content_hash":"1f8eca193fdcd80b255add35c43ecfb288ac9b97c958e68e9d6a6a2e7d1e82ab","title":"Tests for AsyncRLMExecutor","description":"Comprehensive tests for async execution.\n\n## Test Categories\n\n### Unit Tests\n- ExecuteParallel with independent operations\n- ExecuteParallel with varying concurrency limits\n- SpeculativeExecute cancels slower alternatives\n- Error handling for partial failures\n- Budget enforcement during parallel execution\n\n### Property-Based Tests (rapid)\n- Invariant: all results returned match operations\n- Invariant: concurrency never exceeds limit\n- Invariant: budget never exceeded\n\n### Integration Tests\n- AsyncRLMExecutor with real LLM calls\n- Interaction with existing Controller\n- Timeout handling\n\n### Benchmarks\n- Latency comparison: sync vs async (3-5x expected)\n- Memory overhead of parallel execution","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-13T19:54:32.853024-07:00","updated_at":"2026-01-14T08:15:43.301327-07:00","closed_at":"2026-01-14T08:15:43.301327-07:00","source_repo":".","labels":["async","testing"],"dependencies":[{"issue_id":"recurse-nyu","depends_on_id":"recurse-k3i","type":"blocks","created_at":"2026-01-13T20:00:23.164133-07:00","created_by":"daemon"}]}
{"id":"recurse-o3l","content_hash":"59adb34f21d13f3203d4b89f45727e3c9bc23d346fd143495819f424b4d16961","title":"[SPEC] Modular Orchestrator Package Design","description":"Design specification for modular orchestrator refactoring.\n\n## Current State\ncontroller.go, wrapper.go, orchestrator.go have overlapping responsibilities.\n\n## Requirements\n- Define orchestrator/ package structure\n- Specify core.go for base loop\n- Specify intelligent.go for Claude-powered decisions\n- Specify async.go for async execution\n- Specify checkpointing.go for session persistence\n- Specify steering.go for user interaction\n\n## Deliverables\n- Spec document: docs/spec/modular-orchestrator.md\n- Package structure: internal/rlm/orchestrator/\n\n## Acceptance Criteria\n- [ ] Spec defines clear separation of concerns\n- [ ] Spec covers interface between modules\n- [ ] Spec covers migration from current structure\n- [ ] Spec defines public API surface","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T19:59:32.20145-07:00","updated_at":"2026-01-13T20:33:52.889373-07:00","closed_at":"2026-01-13T20:33:52.889373-07:00","source_repo":".","labels":["architecture","refactor","spec"],"dependencies":[{"issue_id":"recurse-o3l","depends_on_id":"recurse-cit","type":"parent-child","created_at":"2026-01-13T20:02:28.025458-07:00","created_by":"daemon"}]}
{"id":"recurse-opt","content_hash":"d3da6270186114645e508368ac0f080d86fbf56ca0582283db257cec4806937c","title":"Add status bar to TUI","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-10T12:14:02.072475-07:00","updated_at":"2026-01-10T12:43:46.335816-07:00","closed_at":"2026-01-10T12:43:46.335816-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-opt","depends_on_id":"recurse-6f6","type":"blocks","created_at":"2026-01-10T12:14:58.990674-07:00","created_by":"daemon"}]}
{"id":"recurse-oz2","content_hash":"a997c4bb770df72c415a83801cb832b727d9d79140145ce8065c1c980c4616ae","title":"Implement RLM Observability Package","description":"Add observability infrastructure for RLM components.\n\n## Components\n- Metrics collector for async executor, cache, circuit breaker\n- Structured event logging\n- OpenTelemetry-compatible tracing spans\n\n## Key Metrics\n- rlm_calls_total (counter)\n- rlm_call_duration_seconds (histogram)\n- rlm_cache_hits_total, rlm_cache_misses_total\n- rlm_circuit_breaker_state\n- rlm_async_parallel_executions (gauge)\n\n## Deliverables\n- internal/rlm/observability/metrics.go\n- internal/rlm/observability/tracer.go\n- internal/rlm/observability/events.go","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-14T08:42:46.699845-07:00","updated_at":"2026-01-14T08:46:47.000013-07:00","closed_at":"2026-01-14T08:46:47.000013-07:00","source_repo":".","labels":["infrastructure","metrics","observability"]}
{"id":"recurse-q7e","content_hash":"f25cb3f0d1a9afa634123db593800685a9e154dbb92d63470bc2804870953842","title":"Implement decay and pruning with archive tier","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T06:46:49.817965-07:00","updated_at":"2026-01-11T06:56:41.967696-07:00","closed_at":"2026-01-11T06:56:41.967696-07:00","source_repo":"."}
{"id":"recurse-qdb","content_hash":"768a86452954b6daad3101c18432370aeb2b3e15d44a376508f807980a50eb6c","title":"RLM Enhancement: Performance Optimizations","description":"Performance optimizations for latency, cost, and scaling.\n\nResearch basis:\n- KVzip (SNU 2025): 3-4x memory compression with 2x latency reduction\n- Inference Scaling Laws (ICLR 2025): 4x efficiency through adaptive compute\n\nIncludes:\n- Context compression (extractive + abstractive)\n- Compute-optimal depth allocation\n- Query difficulty estimation","status":"in_progress","priority":1,"issue_type":"epic","created_at":"2026-01-13T19:53:07.356562-07:00","updated_at":"2026-01-14T08:42:09.853304-07:00","source_repo":".","labels":["optimization","performance","rlm"]}
{"id":"recurse-qm2","content_hash":"1f30a1aeb4780b002d4794eb52262173b35ea4e2cb75b429823a513a0ce6adbf","title":"Implement EmbeddingClient and VoyageClient","description":"Implement embedding client abstraction and Voyage provider.\n\n## Implementation\n- Create internal/memory/hypergraph/embeddings.go\n- Define EmbeddingClient interface\n- Implement VoyageClient for Voyage-3/VoyageCode-3\n- Add batch embedding support\n- Add caching for frequently embedded content\n\n## Key Types\n```go\ntype EmbeddingClient interface {\n    Embed(ctx context.Context, texts []string) ([][]float32, error)\n    Model() string\n    Dimensions() int\n}\n\ntype VoyageClient struct {\n    apiKey string\n    model  string // \"voyage-3\" or \"voyage-code-3\"\n}\n```","status":"closed","priority":0,"issue_type":"feature","created_at":"2026-01-13T19:54:34.070593-07:00","updated_at":"2026-01-14T08:03:54.240009-07:00","closed_at":"2026-01-14T08:03:54.240009-07:00","source_repo":".","labels":["embeddings","implementation","memory"],"dependencies":[{"issue_id":"recurse-qm2","depends_on_id":"recurse-eim","type":"blocks","created_at":"2026-01-13T20:00:23.874932-07:00","created_by":"daemon"}]}
{"id":"recurse-r26","content_hash":"01ec077fa91706baeaa71b7be6663820f6c659e0a6d24e3f7624245fd3fe394f","title":"[SPEC] Formal Verification Integration Design","description":"Design specification for formal verification of code changes.\n\n## Research Basis\nPREFACE (GLSVLSI 2025) achieves formally verifiable code generation via RL-guided prompt repair.\n\n## Requirements\n- Define VerificationChain interface\n- Specify constraint types (type_check, call_graph, invariant)\n- Design precondition/postcondition generation\n- Specify CPMpy integration via REPL\n- Define verification result structure\n\n## Deliverables\n- Spec document: docs/spec/formal-verification.md\n- Interface: internal/rlm/verify/chain.go\n\n## Acceptance Criteria\n- [ ] Spec covers constraint generation from docstrings\n- [ ] Spec covers CPMpy model construction\n- [ ] Spec covers verification result interpretation\n- [ ] Spec defines integration with code change workflow","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T19:56:14.602633-07:00","updated_at":"2026-01-13T21:01:27.991398-07:00","closed_at":"2026-01-13T21:01:27.991398-07:00","source_repo":".","labels":["formal","spec","verification"],"dependencies":[{"issue_id":"recurse-r26","depends_on_id":"recurse-5gr","type":"parent-child","created_at":"2026-01-13T20:02:09.268677-07:00","created_by":"daemon"}]}
{"id":"recurse-rkg","content_hash":"143bee38f0abf505b426b68a068a21ef3d5d704c8a70244071b0ff37769aa779","title":"Implement basic RLM tools","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T12:14:01.37654-07:00","updated_at":"2026-01-10T12:32:49.458737-07:00","closed_at":"2026-01-10T12:32:49.458737-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-rkg","depends_on_id":"recurse-2ih","type":"blocks","created_at":"2026-01-10T12:14:58.809764-07:00","created_by":"daemon"}]}
{"id":"recurse-rxw","content_hash":"08f97f4325e0a9d1161c417efbc4fce871cd1f9b9301e7072bb12df2178a7282","title":"[SPEC] Circuit Breaker Pattern Design","description":"Design specification for circuit breaker resilience pattern.\n\n## Research Basis\nStandard distributed systems pattern for preventing cascade failures.\n\n## Requirements\n- Define circuit breaker states (Closed, Open, HalfOpen)\n- Specify failure counting and threshold\n- Define recovery timeout and half-open testing\n- Specify per-model-tier circuit breakers\n- Define fallback behavior when circuit open\n\n## Deliverables\n- Spec document: docs/spec/circuit-breaker.md\n- Interface: internal/rlm/resilience/breaker.go\n\n## Acceptance Criteria\n- [ ] Spec covers state machine transitions\n- [ ] Spec covers failure threshold configuration\n- [ ] Spec covers recovery timeout and testing\n- [ ] Spec covers per-model-tier isolation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-13T19:54:37.82999-07:00","updated_at":"2026-01-13T20:20:29.673305-07:00","closed_at":"2026-01-13T20:20:29.673305-07:00","source_repo":".","labels":["reliability","resilience","spec"],"dependencies":[{"issue_id":"recurse-rxw","depends_on_id":"recurse-038","type":"parent-child","created_at":"2026-01-13T20:02:06.330608-07:00","created_by":"daemon"}]}
{"id":"recurse-s8n","content_hash":"88d67b3951d585f6c062914865296c502c5b54ddefcbed14070f24b594977742","title":"Tests for Context Compression","description":"Tests for context compression implementation.\n\n## Test Categories\n\n### Unit Tests\n- Extractive compression selects top sentences\n- Abstractive compression respects token limit\n- Two-stage pipeline activates at thresholds\n- Small content passes through unchanged\n\n### Property-Based Tests\n- Invariant: compressed output \u003c= target tokens\n- Invariant: key information preserved (semantic similarity)\n\n### Integration Tests\n- End-to-end compression with real content\n- Quality comparison: original vs compressed\n\n### Benchmarks\n- Compression ratio by content type\n- Latency: extractive vs abstractive vs two-stage","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-13T19:57:03.132145-07:00","updated_at":"2026-01-14T10:01:23.138285-07:00","closed_at":"2026-01-14T10:01:23.138285-07:00","source_repo":".","labels":["compression","testing"],"dependencies":[{"issue_id":"recurse-s8n","depends_on_id":"recurse-jow","type":"blocks","created_at":"2026-01-13T20:01:08.572751-07:00","created_by":"daemon"}]}
{"id":"recurse-smo","content_hash":"778a3ca406d9d1f9e8c54a98ac937522af220d1be1f48e4ba44fee1d2e4b85b5","title":"Implement tier promotion logic (task → session → long-term)","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T06:46:49.640932-07:00","updated_at":"2026-01-11T06:54:56.512949-07:00","closed_at":"2026-01-11T06:54:56.512949-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-smo","depends_on_id":"recurse-asp","type":"blocks","created_at":"2026-01-11T06:47:49.435284-07:00","created_by":"daemon"}]}
{"id":"recurse-t8p","content_hash":"f1f783db5c562681ff86b2dce7778c2a8d644cdc2856af76506465029d69d9f1","title":"[SPEC] REPL Plugin System Design","description":"Design specification for REPL plugin system.\n\n## Research Basis\nRLM paper shows emergent strategies vary by domain. Extensibility enables domain-specific functions.\n\n## Requirements\n- Define REPLPlugin interface\n- Specify REPLFunction registration\n- Design plugin loading from filesystem\n- Define security constraints for plugins\n- Specify example plugins (code_analysis)\n\n## Deliverables\n- Spec document: docs/spec/repl-plugins.md\n- Interface: internal/rlm/repl/plugin.go\n\n## Acceptance Criteria\n- [ ] Spec covers plugin interface\n- [ ] Spec covers function registration\n- [ ] Spec covers security model\n- [ ] Spec defines plugin discovery\n- [ ] Spec includes example plugin","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T19:59:34.381838-07:00","updated_at":"2026-01-13T20:33:52.159267-07:00","closed_at":"2026-01-13T20:33:52.159267-07:00","source_repo":".","labels":["plugins","repl","spec"],"dependencies":[{"issue_id":"recurse-t8p","depends_on_id":"recurse-cit","type":"parent-child","created_at":"2026-01-13T20:02:28.789778-07:00","created_by":"daemon"}]}
{"id":"recurse-ufu","content_hash":"8125f3cf83e6dac32688518e414b351ec594f85532e07795dea2694a94010715","title":"Epic: Phase 6 - CLI Wiring","description":"","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-11T07:13:21.853298-07:00","updated_at":"2026-01-11T07:20:39.383751-07:00","closed_at":"2026-01-11T07:20:39.383751-07:00","source_repo":"."}
{"id":"recurse-vhe","content_hash":"e507a66d3c2c8d2c6538b46cbaf896e36001d99f69575401f6fee10743efa289","title":"Epic: Phase 4 - Memory Evolution","description":"","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-11T06:46:44.783698-07:00","updated_at":"2026-01-11T06:58:47.021524-07:00","closed_at":"2026-01-11T06:58:47.021524-07:00","source_repo":"."}
{"id":"recurse-vst","content_hash":"580eb09ff04d994cf640f5239cfbe9406ce41c6276e11587d1701835bcb2cae0","title":"[SPEC] Tree of Thoughts Integration Design","description":"Design specification for Tree of Thoughts integration with RLM.\n\n## Research Basis\nTree of Thoughts (NeurIPS 2023) showed 4%-74% improvement on complex reasoning tasks through deliberate exploration with backtracking.\n\n## Requirements\n- Define ThoughtNode structure with state, value, children\n- Specify branching strategy (generate N thoughts per node)\n- Define exploration strategies (BFS, DFS, best-first)\n- Specify self-evaluation for state scoring\n- Define integration points with RLM Controller\n- Specify when to activate ToT vs linear decomposition\n\n## Deliverables\n- Spec document: docs/spec/tree-of-thoughts.md\n- Interface: internal/rlm/tot/tree.go\n- Activation heuristics: internal/rlm/tot/activation.go\n\n## Acceptance Criteria\n- [ ] Spec covers ThoughtTree data structure\n- [ ] Spec covers exploration strategies\n- [ ] Spec covers state evaluation via meta-controller\n- [ ] Spec covers backtracking mechanism\n- [ ] Spec defines ToT activation triggers","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-13T19:56:07.170346-07:00","updated_at":"2026-01-13T20:20:28.368131-07:00","closed_at":"2026-01-13T20:20:28.368131-07:00","source_repo":".","labels":["reasoning","spec","tot"],"dependencies":[{"issue_id":"recurse-vst","depends_on_id":"recurse-5gr","type":"parent-child","created_at":"2026-01-13T20:02:07.106547-07:00","created_by":"daemon"}]}
{"id":"recurse-vuq","content_hash":"42dcf8c64dbefc0b81edb54bac31ea39244accde907d478e23188a4cb29f9eff","title":"Epic: Transform RLM into true recursive language model system","description":"Transform the current RLM implementation from a simple REPL tool into a true Recursive Language Model system based on Zhang \u0026 Khattab (2025) research. The core innovation is treating context as manipulable external data that the LLM examines programmatically, enabling recursive sub-LLM calls and emergent strategies like peeking, grepping, partition+map, and summarization.","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-11T15:50:25.898335-07:00","updated_at":"2026-01-12T10:05:19.822848-07:00","closed_at":"2026-01-12T10:05:19.822848-07:00","source_repo":"."}
{"id":"recurse-vuq.1","content_hash":"643d1c9f22a5b80e6327857e6d781957dc00c5508ce30813d98b1cbff6627a22","title":"Context externalization: Store prompts/context as REPL variables","description":"Implement the core RLM innovation: instead of directly ingesting context, store it as Python variables in the REPL. The root LLM receives only the query and interacts with context through code. Key changes:\n1. Context stored in REPL as in-memory variable (e.g., 'context', 'documents')\n2. Root LLM gets query only, not full context\n3. LLM writes code to examine/filter/transform context\n4. Support for arbitrary context types (text, JSON, code files)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-11T15:50:32.70245-07:00","updated_at":"2026-01-11T15:59:40.312352-07:00","closed_at":"2026-01-11T15:59:40.312352-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-vuq.1","depends_on_id":"recurse-vuq","type":"parent-child","created_at":"2026-01-11T15:50:32.703491-07:00","created_by":"daemon"},{"issue_id":"recurse-vuq.1","depends_on_id":"recurse-vuq.2","type":"blocks","created_at":"2026-01-11T15:51:43.796534-07:00","created_by":"daemon"},{"issue_id":"recurse-vuq.1","depends_on_id":"recurse-vuq.4","type":"blocks","created_at":"2026-01-11T15:51:43.901223-07:00","created_by":"daemon"}]}
{"id":"recurse-vuq.2","content_hash":"f351c1c7acf3ae5d8473d291634bb82409f84fc0b4b7eec0d9eacf98e27c6a92","title":"Recursive sub-LLM calls: Enable spawning isolated sub-RLM instances","description":"Implement the ability for the root LLM to spawn recursive sub-LLM instances from within the REPL. Key features:\n1. llm_call(prompt, context_slice) - invoke sub-LLM on specific context\n2. llm_batch(prompts) - parallel sub-LLM calls for efficiency\n3. Isolated environments per sub-call (no cross-contamination)\n4. Results returned as Python objects for aggregation\n5. Depth tracking to prevent infinite recursion\n6. Budget allocation per sub-call\n\nThis enables partition+map strategies where chunks are processed in parallel.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-11T15:50:40.150622-07:00","updated_at":"2026-01-11T16:13:05.956164-07:00","closed_at":"2026-01-11T16:13:05.956164-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-vuq.2","depends_on_id":"recurse-vuq","type":"parent-child","created_at":"2026-01-11T15:50:40.151849-07:00","created_by":"daemon"},{"issue_id":"recurse-vuq.2","depends_on_id":"recurse-vuq.3","type":"blocks","created_at":"2026-01-11T15:51:44.008097-07:00","created_by":"daemon"},{"issue_id":"recurse-vuq.2","depends_on_id":"recurse-vuq.6","type":"blocks","created_at":"2026-01-11T15:51:50.592776-07:00","created_by":"daemon"}]}
{"id":"recurse-vuq.3","content_hash":"a7582e521b04544a48eb56eed67443d28d72f0eb7bfc05c446bdfea37d67fc0a","title":"Intelligent model routing via OpenRouter for sub-calls","description":"Route sub-LLM calls to optimal models based on task characteristics using the OpenRouter integration. Key features:\n1. Task analysis to determine required tier (Fast/Balanced/Powerful/Reasoning)\n2. Budget-aware routing (cheaper models for simple sub-tasks)\n3. Depth-aware routing (simpler models at higher recursion depth)\n4. Keyword-based routing (math→reasoning tier, code→coding model)\n5. Cost tracking and optimization\n6. Fallback chains when models fail\n\nInspired by NVIDIA ToolOrchestra's multi-objective optimization.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-11T15:50:47.707906-07:00","updated_at":"2026-01-11T16:04:26.88622-07:00","closed_at":"2026-01-11T16:04:26.88622-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-vuq.3","depends_on_id":"recurse-vuq","type":"parent-child","created_at":"2026-01-11T15:50:47.709266-07:00","created_by":"daemon"}]}
{"id":"recurse-vuq.4","content_hash":"f1750a538ec2939d0d9ea03c677dad321bea0adc2f8696e0140ca03e30bda066","title":"Emergent strategies: Implement peek/grep/partition patterns","description":"Enable the emergent strategies discovered in RLM research:\n\n1. **Peeking**: Examine initial context segments to understand structure before full processing\n2. **Grepping**: Use regex/keyword patterns to narrow search without semantic retrieval overhead\n3. **Partition+Map**: Chunk context into smaller segments and execute recursive LLM calls\n4. **Summarization**: Compress information subsets for outer LLM decision-making\n5. **Programmatic execution**: Handle long-output generation through code rather than token generation\n\nProvide helper functions in REPL: peek(n), grep(pattern), partition(chunk_size), summarize(text)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-11T15:50:54.151382-07:00","updated_at":"2026-01-11T16:15:00.28322-07:00","closed_at":"2026-01-11T16:15:00.28322-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-vuq.4","depends_on_id":"recurse-vuq","type":"parent-child","created_at":"2026-01-11T15:50:54.153224-07:00","created_by":"daemon"},{"issue_id":"recurse-vuq.4","depends_on_id":"recurse-vuq.6","type":"blocks","created_at":"2026-01-11T15:51:50.687766-07:00","created_by":"daemon"}]}
{"id":"recurse-vuq.5","content_hash":"5f1ac7a9693d96cb18e28537a6fa4ae3bf24ca008ee205e6181238aecb272a34","title":"FINAL() output mechanism for answer construction","description":"Implement the RLM output mechanism where models conclude with structured answer tags:\n\n1. FINAL(answer) - Return direct answer string\n2. FINAL_VAR(variable_name) - Return constructed answer from REPL variable\n3. Answer variable 'answer' that model iteratively refines\n4. Validation that answer is provided before completion\n5. Support for structured outputs (JSON, code, etc.)\n\nThis forces strategic delegation rather than context overload - the model can only provide answers via the environment.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-11T15:51:01.462039-07:00","updated_at":"2026-01-11T16:17:00.544163-07:00","closed_at":"2026-01-11T16:17:00.544163-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-vuq.5","depends_on_id":"recurse-vuq","type":"parent-child","created_at":"2026-01-11T15:51:01.463037-07:00","created_by":"daemon"},{"issue_id":"recurse-vuq.5","depends_on_id":"recurse-vuq.6","type":"blocks","created_at":"2026-01-11T15:51:50.779598-07:00","created_by":"daemon"}]}
{"id":"recurse-vuq.6","content_hash":"e72cefacd114aaf23c8b5debac330d557ffe7b89e6cd7bcc67081dc616573531","title":"RLM agent integration: Replace direct prompts with RLM wrapper","description":"Integrate true RLM as the primary inference strategy for the agent:\n\n1. Wrap all agent prompts through RLM interface\n2. Large context (files, search results) goes to REPL, not direct prompt\n3. Agent reasons about context via code before responding\n4. Seamless fallback to direct mode for simple queries\n5. Trace recording for all RLM operations\n6. Cost/token tracking across recursive calls\n\nThe interface should be transparent: rlm.completion(messages) replaces model.completion(messages)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-11T15:51:10.126445-07:00","updated_at":"2026-01-11T16:07:26.125802-07:00","closed_at":"2026-01-11T16:07:26.125802-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-vuq.6","depends_on_id":"recurse-vuq","type":"parent-child","created_at":"2026-01-11T15:51:10.128063-07:00","created_by":"daemon"}]}
{"id":"recurse-vuq.7","content_hash":"11e1fd5b0be2127a3f23dd9b41042edf0dcf6a204e5c12816e95a3c80158326d","title":"Hypergraph memory integration with RLM context","description":"Integrate the existing hypergraph memory system with RLM context management:\n\n1. Memory queries accessible from REPL: memory.query(topic)\n2. Store RLM execution traces as experience nodes\n3. Cache successful decomposition strategies\n4. Learn from past context patterns\n5. Cross-session knowledge transfer\n6. Memory-guided context prioritization\n\nThe hypergraph provides long-term memory while REPL provides working memory.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-11T15:51:16.854104-07:00","updated_at":"2026-01-11T16:22:07.329559-07:00","closed_at":"2026-01-11T16:22:07.329559-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-vuq.7","depends_on_id":"recurse-vuq","type":"parent-child","created_at":"2026-01-11T15:51:16.855327-07:00","created_by":"daemon"}]}
{"id":"recurse-vuq.8","content_hash":"8becf43268e86233b252e1a50cc9801c35e1ca1f31b86dc3adac6b125ce1a77d","title":"RLM benchmarks: Implement OOLONG and long-context evaluation","description":"Create benchmarks to measure RLM effectiveness based on the research:\n\n1. Context rot evaluation - performance vs context length\n2. Multi-hop reasoning across large document sets\n3. Partition+map efficiency tests\n4. Cost/accuracy tradeoff measurements\n5. Comparison with direct prompting baseline\n6. Recursion depth impact analysis\n\nTarget metrics from research: 114% improvement at 132k tokens, 58% F1 on tasks where base models get \u003c0.1%","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-11T15:51:25.109913-07:00","updated_at":"2026-01-11T17:19:55.026582-07:00","closed_at":"2026-01-11T17:19:55.026582-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-vuq.8","depends_on_id":"recurse-vuq","type":"parent-child","created_at":"2026-01-11T15:51:25.110674-07:00","created_by":"daemon"}]}
{"id":"recurse-vuq.9","content_hash":"d6a3b22d9a9faa50ebca3136890c148a1762e9679abda78d62284d5e24e78d3f","title":"Future: RL-trained orchestration policy (ToolOrchestra-inspired)","description":"Long-term goal: Train orchestration policies via reinforcement learning (inspired by NVIDIA ToolOrchestra):\n\n1. Multi-objective reward: accuracy + cost + latency + user preference\n2. Learn when to decompose vs direct answer\n3. Learn optimal model routing per task type\n4. Generalization to unseen tools and contexts\n5. Group Relative Policy Optimization (GRPO)\n6. Synthetic training data generation\n\nThis represents the next evolution after basic RLM - learned orchestration rather than heuristic-based.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-11T15:51:32.181735-07:00","updated_at":"2026-01-12T10:05:11.443409-07:00","closed_at":"2026-01-12T10:05:11.443409-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-vuq.9","depends_on_id":"recurse-vuq","type":"parent-child","created_at":"2026-01-11T15:51:32.182937-07:00","created_by":"daemon"}]}
{"id":"recurse-vve","content_hash":"f6191d6dad6d1f3b061685e1881b82706fb7bb158724081ae200f9986a33e054","title":"Bootstrap Python environment with uv/ruff/ty/pydantic","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T12:14:01.078306-07:00","updated_at":"2026-01-10T12:41:58.987768-07:00","closed_at":"2026-01-10T12:41:58.987768-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-vve","depends_on_id":"recurse-2ih","type":"blocks","created_at":"2026-01-10T12:14:58.718027-07:00","created_by":"daemon"}]}
{"id":"recurse-wu9","content_hash":"f84af55cc3905ddd0d89564e3ddc091519aa118724be50c9fe5fc3cecf21e6fe","title":"Document user journeys and OODA loops for agentic development","description":"Create documentation mapping the intended user experience:\n\n**Primary user journey: Agentic coding session**\n1. Start `recurse` in interactive mode\n2. Submit complex coding task\n3. Observe RLM decomposition in trace view\n4. See Python REPL processing context\n5. Review synthesized response\n6. Ask follow-up question (memory retrieval)\n7. End session (memory promotion to longterm)\n\n**OODA loop for each interaction:**\n- **Observe**: See current code state, memory context\n- **Orient**: RLM meta-controller decides strategy\n- **Decide**: Choose DIRECT/DECOMPOSE/MEMORY_QUERY/etc\n- **Act**: Execute chosen strategy, generate response\n\n**Jobs to be done:**\n1. Understand large codebase quickly\n2. Make changes across multiple files\n3. Remember context between sessions\n4. Track reasoning for future reference\n\n**Deliverable:** docs/user-journeys.md","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T17:36:32.93175-07:00","updated_at":"2026-01-13T18:44:31.685815-07:00","closed_at":"2026-01-13T18:44:31.685815-07:00","source_repo":".","labels":["docs","ux"]}
{"id":"recurse-wxf","content_hash":"498a1894abdfc15c8a3885e083d55d6fe62a4593dd9746d23b8250ee5320a30d","title":"Wire meta-controller decisions to trace provider","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T06:59:39.964957-07:00","updated_at":"2026-01-11T07:04:52.093079-07:00","closed_at":"2026-01-11T07:04:52.093079-07:00","source_repo":"."}
{"id":"recurse-xwr","content_hash":"aee96216701fe1db677857d2396d66d3a3f53ee1e737fffe746041cf3726d605","title":"[SPEC] Continuous Learning Design","description":"Design specification for outcome-based continuous learning.\n\n## Research Basis\nAgent Lightning (Microsoft, 2025) enables RL-based training with zero code modifications.\n\n## Requirements\n- Define ExecutionOutcome structure\n- Specify signal extraction from outcomes\n- Design learning rate and adjustment strategy\n- Define persistence for cross-session learning\n- Specify integration with routing and orchestration\n\n## Deliverables\n- Spec document: docs/spec/continuous-learning.md\n- Interface: internal/rlm/learning/learner.go\n\n## Acceptance Criteria\n- [ ] Spec covers outcome recording\n- [ ] Spec covers signal extraction\n- [ ] Spec covers adjustment computation\n- [ ] Spec covers persistence strategy\n- [ ] Spec defines integration points","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T19:58:37.049646-07:00","updated_at":"2026-01-13T21:01:26.121534-07:00","closed_at":"2026-01-13T21:01:26.121534-07:00","source_repo":".","labels":["adaptation","learning","spec"],"dependencies":[{"issue_id":"recurse-xwr","depends_on_id":"recurse-kes","type":"parent-child","created_at":"2026-01-13T20:02:25.74284-07:00","created_by":"daemon"}]}
{"id":"recurse-xyh","content_hash":"6a06d54fbf443587c6a088fede8f2b1616d8a5bf7ba0dcf5e0d214a599ae43b9","title":"Add explicit mode override API for RLM/Direct selection","description":"Allow callers to explicitly force RLM or Direct mode, bypassing automatic selection.\n\n**Use Cases**:\n1. Force RLM for small computational tasks (below 4K threshold)\n2. Force Direct for large simple retrievals (speed over efficiency)\n3. Testing and benchmarking specific modes\n4. User preference override\n\n**API Design**:\n```go\ntype ModeOverride string\nconst (\n    ModeOverrideAuto   ModeOverride = \"auto\"   // Use automatic selection (default)\n    ModeOverrideRLM    ModeOverride = \"rlm\"    // Force RLM mode\n    ModeOverrideDirect ModeOverride = \"direct\" // Force Direct mode\n)\n\n// Add to PrepareContext options\ntype PrepareOptions struct {\n    ModeOverride ModeOverride\n}\n\nfunc (w *Wrapper) PrepareContextWithOptions(ctx context.Context, prompt string, \n    contexts []ContextSource, opts PrepareOptions) (*PreparedPrompt, error)\n```\n\n**CLI Integration**:\n```bash\nrecurse --mode=rlm \"count words in file.txt\"\nrecurse --mode=direct \"find the API key\"\n```\n\n**Config Support**:\n```yaml\nrlm:\n  default_mode: auto  # auto|rlm|direct\n```","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-12T08:05:45.950168-07:00","updated_at":"2026-01-12T08:57:50.42357-07:00","closed_at":"2026-01-12T08:57:50.42357-07:00","source_repo":"."}
{"id":"recurse-yb6","content_hash":"52e53d0d9d1bd2527b3fca0d9f8cb1b5fd69a7cc40cdca16d69e13f83aae7eea","title":"Tests for Proactive REPL","description":"Tests for proactive REPL computation detection.\n\n## Test Categories\n\n### Unit Tests\n- Pattern matching for counting queries\n- Pattern matching for arithmetic queries\n- Pattern matching for sorting queries\n- Suggestion generation for each pattern\n\n### Integration Tests\n- ComputationAdvisor with orchestrator\n- End-to-end REPL suggestion flow\n\n### Benchmark\n- Pattern matching latency (\u003c1ms target)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-13T19:56:13.88942-07:00","updated_at":"2026-01-13T19:56:13.88942-07:00","source_repo":".","labels":["repl","testing"],"dependencies":[{"issue_id":"recurse-yb6","depends_on_id":"recurse-beh","type":"blocks","created_at":"2026-01-13T20:00:50.525808-07:00","created_by":"daemon"}]}
{"id":"recurse-yb9","content_hash":"3146c4cd29848e51099d3f81e1c03076255545809114843d9eac11cbf1745caa","title":"Tests for Correction Learning","description":"Tests for user correction learning.\n\n## Test Categories\n\n### Unit Tests\n- RecordCorrection stores correctly\n- Pattern analysis identifies trends\n- Corrections update learner\n\n### Integration Tests\n- End-to-end correction flow\n- Adjustments affect future routing","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T19:58:42.737424-07:00","updated_at":"2026-01-14T11:59:39.257346-07:00","closed_at":"2026-01-14T11:59:39.257346-07:00","source_repo":".","labels":["corrections","testing"],"dependencies":[{"issue_id":"recurse-yb9","depends_on_id":"recurse-39i","type":"blocks","created_at":"2026-01-13T20:01:33.421308-07:00","created_by":"daemon"}]}
{"id":"recurse-ys9","content_hash":"5256da75f04d7e473bf67df21aa96192c3be20da70f78271de436079f5021a16","title":"Implement rlm_subcall tool for sub-LM invocation","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T06:23:54.697947-07:00","updated_at":"2026-01-11T06:40:37.858163-07:00","closed_at":"2026-01-11T06:40:37.858163-07:00","source_repo":".","dependencies":[{"issue_id":"recurse-ys9","depends_on_id":"recurse-c0d","type":"blocks","created_at":"2026-01-11T06:29:26.062042-07:00","created_by":"daemon"}]}
{"id":"recurse-zb2","content_hash":"955fac1bfc328e4c4aac16ac9ba157560bf1ab89284b91316849f9d934b1198a","title":"Tests for Learned Routing","description":"Tests for learned model routing.\n\n## Test Categories\n\n### Unit Tests\n- Route returns valid model\n- Learned adjustments affect routing\n- Cascade escalates on low confidence\n- Cost sensitivity affects selection\n\n### Integration Tests\n- End-to-end with real models\n- Cost comparison: static vs learned\n\n### Benchmarks\n- Routing decision latency\n- Cost reduction measurement","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-13T19:58:40.713689-07:00","updated_at":"2026-01-14T11:59:38.647123-07:00","closed_at":"2026-01-14T11:59:38.647123-07:00","source_repo":".","labels":["routing","testing"],"dependencies":[{"issue_id":"recurse-zb2","depends_on_id":"recurse-7wg","type":"blocks","created_at":"2026-01-13T20:01:31.230926-07:00","created_by":"daemon"}]}
{"id":"recurse-zhb","content_hash":"c00147e75e64bdca4feffd19d470006c06cfeb76eec2c350fc608885bb9e0df7","title":"Wire RLM Service to App","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T07:13:26.907538-07:00","updated_at":"2026-01-11T07:15:50.757517-07:00","closed_at":"2026-01-11T07:15:50.757517-07:00","source_repo":"."}
{"id":"recurse-zro","content_hash":"3ca7765111cea73e9eb03b6730c6c5d1f1d89ffb8725162f77ae491c68afbd5d","title":"Regenerate VCR agent test fixtures after RLM integration","description":"The VCR test fixtures in internal/agent/testdata/ need to be regenerated after integrating RLM. The system prompt now includes Python REPL instructions and the project name changed from Crush to Recurse. Regeneration requires API keys for Anthropic, OpenAI, OpenRouter, and ZAI.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-11T16:39:49.222157-07:00","updated_at":"2026-01-11T16:59:56.22299-07:00","closed_at":"2026-01-11T16:59:56.22299-07:00","source_repo":"."}
